/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#include "artsflow.h"

// Implementation
Arts::AudioManagerInfo::AudioManagerInfo()
{
}

Arts::AudioManagerInfo::AudioManagerInfo(long _a_ID, const std::string& _a_destination, Arts::AudioManagerDirection _a_direction, const std::string& _a_title, const std::string& _a_autoRestoreID)
{
	this->ID = _a_ID;
	this->destination = _a_destination;
	this->direction = _a_direction;
	this->title = _a_title;
	this->autoRestoreID = _a_autoRestoreID;
}

Arts::AudioManagerInfo::AudioManagerInfo(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::AudioManagerInfo::AudioManagerInfo(const Arts::AudioManagerInfo& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::AudioManagerInfo& Arts::AudioManagerInfo::operator=(const Arts::AudioManagerInfo& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::AudioManagerInfo::readType(Arts::Buffer& stream)
{
	ID = stream.readLong();
	stream.readString(destination);
	direction = (Arts::AudioManagerDirection)stream.readLong();
	stream.readString(title);
	stream.readString(autoRestoreID);
}

void Arts::AudioManagerInfo::writeType(Arts::Buffer& stream) const
{
	stream.writeLong(ID);
	stream.writeString(destination);
	stream.writeLong(direction);
	stream.writeString(title);
	stream.writeString(autoRestoreID);
}

std::string Arts::AudioManagerInfo::_typeName() const
{
	return "Arts::AudioManagerInfo";
}

Arts::SynthModule_base *Arts::SynthModule_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::SynthModule_base *castedObject = (Arts::SynthModule_base *)skel->_cast(Arts::SynthModule_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::SynthModule_base *Arts::SynthModule_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::SynthModule_base::_fromReference(r,true);
	return 0;
}

Arts::SynthModule_base *Arts::SynthModule_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::SynthModule_base *castedObject = (Arts::SynthModule_base *)object._base()->_cast(Arts::SynthModule_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::SynthModule_base *Arts::SynthModule_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::SynthModule_base *result;
	result = (Arts::SynthModule_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::SynthModule");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::SynthModule_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::SynthModule")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::SynthModule_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::SynthModule_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::SynthModule_base::_cast(unsigned long iid)
{
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::SynthModule_stub::SynthModule_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::SynthModule_stub::SynthModule_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::SynthModule_stub::start()
{
	long methodID = _lookupMethodFast("method:0000000673746172740000000005766f696400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

void Arts::SynthModule_stub::stop()
{
	long methodID = _lookupMethodFast("method:0000000573746f700000000005766f696400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

void Arts::SynthModule_stub::streamInit()
{
	long methodID = _lookupMethodFast("method:0000000b73747265616d496e69740000000005766f696400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

void Arts::SynthModule_stub::streamStart()
{
	long methodID = _lookupMethodFast("method:0000000c73747265616d53746172740000000005766f696400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

void Arts::SynthModule_stub::streamEnd()
{
	long methodID = _lookupMethodFast("method:0000000a73747265616d456e640000000005766f696400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

Arts::AutoSuspendState Arts::SynthModule_stub::autoSuspend()
{
	long methodID = _lookupMethodFast("method:000000115f6765745f6175746f53757370656e640000000017417274733a3a4175746f53757370656e64537461746500000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return (Arts::AutoSuspendState)0; // error occurred
	Arts::AutoSuspendState returnCode = (Arts::AutoSuspendState)result->readLong();
	delete result;
	return returnCode;
}

std::string Arts::SynthModule_skel::_interfaceName()
{
	return "Arts::SynthModule";
}

bool Arts::SynthModule_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::SynthModule_skel::_interfaceNameSkel()
{
	return "Arts::SynthModule";
}

// start
static void _dispatch_Arts_SynthModule_00(void *object, Arts::Buffer *, Arts::Buffer *)
{
	((Arts::SynthModule_skel *)object)->start();
}

// stop
static void _dispatch_Arts_SynthModule_01(void *object, Arts::Buffer *, Arts::Buffer *)
{
	((Arts::SynthModule_skel *)object)->stop();
}

// streamInit
static void _dispatch_Arts_SynthModule_02(void *object, Arts::Buffer *, Arts::Buffer *)
{
	((Arts::SynthModule_skel *)object)->streamInit();
}

// streamStart
static void _dispatch_Arts_SynthModule_03(void *object, Arts::Buffer *, Arts::Buffer *)
{
	((Arts::SynthModule_skel *)object)->streamStart();
}

// streamEnd
static void _dispatch_Arts_SynthModule_04(void *object, Arts::Buffer *, Arts::Buffer *)
{
	((Arts::SynthModule_skel *)object)->streamEnd();
}

// _get_autoSuspend
static void _dispatch_Arts_SynthModule_05(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::SynthModule_skel *)object)->autoSuspend());
}

void Arts::SynthModule_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000673746172740000000005766f6964000000000200000000"
        "000000000000000573746f700000000005766f6964000000000200000000000000"
        "000000000b73747265616d496e69740000000005766f6964000000000200000000"
        "000000000000000c73747265616d53746172740000000005766f69640000000002"
        "00000000000000000000000a73747265616d456e640000000005766f6964000000"
        "00020000000000000000000000115f6765745f6175746f53757370656e64000000"
        "0017417274733a3a4175746f53757370656e645374617465000000000200000000"
        "00000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_SynthModule_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_SynthModule_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_SynthModule_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_SynthModule_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_SynthModule_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_SynthModule_05,this,Arts::MethodDef(m));
}

Arts::SynthModule_skel::SynthModule_skel()
{
}

Arts::Object_base* Arts::SynthModule::_Creator() {
	return Arts::SynthModule_base::_create();
}

unsigned long Arts::SynthModule_base::_IID = Arts::MCOPUtils::makeIID("Arts::SynthModule");

Arts::Synth_PLAY_base *Arts::Synth_PLAY_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_PLAY_base *castedObject = (Arts::Synth_PLAY_base *)skel->_cast(Arts::Synth_PLAY_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_PLAY_base *Arts::Synth_PLAY_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_PLAY_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_PLAY_base *Arts::Synth_PLAY_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_PLAY_base *castedObject = (Arts::Synth_PLAY_base *)object._base()->_cast(Arts::Synth_PLAY_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_PLAY_base *Arts::Synth_PLAY_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_PLAY_base *result;
	result = (Arts::Synth_PLAY_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_PLAY");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_PLAY_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_PLAY")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_PLAY_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("invalue_left");
	ret.push_back("invalue_right");
	return ret;
}
std::vector<std::string> Arts::Synth_PLAY_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::Synth_PLAY_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_PLAY_base::_IID) return (Arts::Synth_PLAY_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_PLAY_stub::Synth_PLAY_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_PLAY_stub::Synth_PLAY_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_PLAY_skel::_interfaceName()
{
	return "Arts::Synth_PLAY";
}

bool Arts::Synth_PLAY_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_PLAY") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_PLAY_skel::_interfaceNameSkel()
{
	return "Arts::Synth_PLAY";
}

void Arts::Synth_PLAY_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_PLAY_skel::Synth_PLAY_skel()
{
	_initStream("invalue_left",&invalue_left,73);
	_initStream("invalue_right",&invalue_right,73);
}

Arts::Object_base* Arts::Synth_PLAY::_Creator() {
	return Arts::Synth_PLAY_base::_create();
}

unsigned long Arts::Synth_PLAY_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_PLAY");

Arts::Synth_RECORD_base *Arts::Synth_RECORD_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_RECORD_base *castedObject = (Arts::Synth_RECORD_base *)skel->_cast(Arts::Synth_RECORD_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_RECORD_base *Arts::Synth_RECORD_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_RECORD_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_RECORD_base *Arts::Synth_RECORD_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_RECORD_base *castedObject = (Arts::Synth_RECORD_base *)object._base()->_cast(Arts::Synth_RECORD_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_RECORD_base *Arts::Synth_RECORD_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_RECORD_base *result;
	result = (Arts::Synth_RECORD_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_RECORD");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_RECORD_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_RECORD")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_RECORD_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::Synth_RECORD_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("left");
	ret.push_back("right");
	return ret;
}

void *Arts::Synth_RECORD_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_RECORD_base::_IID) return (Arts::Synth_RECORD_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_RECORD_stub::Synth_RECORD_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_RECORD_stub::Synth_RECORD_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_RECORD_skel::_interfaceName()
{
	return "Arts::Synth_RECORD";
}

bool Arts::Synth_RECORD_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_RECORD") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_RECORD_skel::_interfaceNameSkel()
{
	return "Arts::Synth_RECORD";
}

void Arts::Synth_RECORD_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_RECORD_skel::Synth_RECORD_skel()
{
	_initStream("left",&left,74);
	_initStream("right",&right,74);
}

Arts::Object_base* Arts::Synth_RECORD::_Creator() {
	return Arts::Synth_RECORD_base::_create();
}

unsigned long Arts::Synth_RECORD_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_RECORD");

Arts::Synth_FREQUENCY_base *Arts::Synth_FREQUENCY_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_FREQUENCY_base *castedObject = (Arts::Synth_FREQUENCY_base *)skel->_cast(Arts::Synth_FREQUENCY_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_FREQUENCY_base *Arts::Synth_FREQUENCY_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_FREQUENCY_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_FREQUENCY_base *Arts::Synth_FREQUENCY_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_FREQUENCY_base *castedObject = (Arts::Synth_FREQUENCY_base *)object._base()->_cast(Arts::Synth_FREQUENCY_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_FREQUENCY_base *Arts::Synth_FREQUENCY_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_FREQUENCY_base *result;
	result = (Arts::Synth_FREQUENCY_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_FREQUENCY");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_FREQUENCY_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_FREQUENCY")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_FREQUENCY_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("frequency");
	return ret;
}
std::vector<std::string> Arts::Synth_FREQUENCY_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("pos");
	return ret;
}

void *Arts::Synth_FREQUENCY_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_FREQUENCY_base::_IID) return (Arts::Synth_FREQUENCY_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_FREQUENCY_stub::Synth_FREQUENCY_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_FREQUENCY_stub::Synth_FREQUENCY_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_FREQUENCY_skel::_interfaceName()
{
	return "Arts::Synth_FREQUENCY";
}

bool Arts::Synth_FREQUENCY_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_FREQUENCY") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_FREQUENCY_skel::_interfaceNameSkel()
{
	return "Arts::Synth_FREQUENCY";
}

void Arts::Synth_FREQUENCY_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_FREQUENCY_skel::Synth_FREQUENCY_skel()
{
	_initStream("frequency",&frequency,9);
	_initStream("pos",&pos,10);
}

Arts::Object_base* Arts::Synth_FREQUENCY::_Creator() {
	return Arts::Synth_FREQUENCY_base::_create();
}

unsigned long Arts::Synth_FREQUENCY_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_FREQUENCY");

Arts::Synth_WAVE_SIN_base *Arts::Synth_WAVE_SIN_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_WAVE_SIN_base *castedObject = (Arts::Synth_WAVE_SIN_base *)skel->_cast(Arts::Synth_WAVE_SIN_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_WAVE_SIN_base *Arts::Synth_WAVE_SIN_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_WAVE_SIN_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_WAVE_SIN_base *Arts::Synth_WAVE_SIN_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_WAVE_SIN_base *castedObject = (Arts::Synth_WAVE_SIN_base *)object._base()->_cast(Arts::Synth_WAVE_SIN_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_WAVE_SIN_base *Arts::Synth_WAVE_SIN_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_WAVE_SIN_base *result;
	result = (Arts::Synth_WAVE_SIN_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_WAVE_SIN");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_WAVE_SIN_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_WAVE_SIN")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_WAVE_SIN_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("pos");
	return ret;
}
std::vector<std::string> Arts::Synth_WAVE_SIN_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outvalue");
	return ret;
}

void *Arts::Synth_WAVE_SIN_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_WAVE_SIN_base::_IID) return (Arts::Synth_WAVE_SIN_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_WAVE_SIN_stub::Synth_WAVE_SIN_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_WAVE_SIN_stub::Synth_WAVE_SIN_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_WAVE_SIN_skel::_interfaceName()
{
	return "Arts::Synth_WAVE_SIN";
}

bool Arts::Synth_WAVE_SIN_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_WAVE_SIN") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_WAVE_SIN_skel::_interfaceNameSkel()
{
	return "Arts::Synth_WAVE_SIN";
}

void Arts::Synth_WAVE_SIN_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_WAVE_SIN_skel::Synth_WAVE_SIN_skel()
{
	_initStream("pos",&pos,9);
	_initStream("outvalue",&outvalue,10);
}

Arts::Object_base* Arts::Synth_WAVE_SIN::_Creator() {
	return Arts::Synth_WAVE_SIN_base::_create();
}

unsigned long Arts::Synth_WAVE_SIN_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_WAVE_SIN");

Arts::Synth_MULTI_ADD_base *Arts::Synth_MULTI_ADD_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_MULTI_ADD_base *castedObject = (Arts::Synth_MULTI_ADD_base *)skel->_cast(Arts::Synth_MULTI_ADD_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_MULTI_ADD_base *Arts::Synth_MULTI_ADD_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_MULTI_ADD_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_MULTI_ADD_base *Arts::Synth_MULTI_ADD_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_MULTI_ADD_base *castedObject = (Arts::Synth_MULTI_ADD_base *)object._base()->_cast(Arts::Synth_MULTI_ADD_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_MULTI_ADD_base *Arts::Synth_MULTI_ADD_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_MULTI_ADD_base *result;
	result = (Arts::Synth_MULTI_ADD_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_MULTI_ADD");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_MULTI_ADD_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_MULTI_ADD")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_MULTI_ADD_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("invalue");
	return ret;
}
std::vector<std::string> Arts::Synth_MULTI_ADD_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outvalue");
	return ret;
}

void *Arts::Synth_MULTI_ADD_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_MULTI_ADD_base::_IID) return (Arts::Synth_MULTI_ADD_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_MULTI_ADD_stub::Synth_MULTI_ADD_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_MULTI_ADD_stub::Synth_MULTI_ADD_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_MULTI_ADD_skel::_interfaceName()
{
	return "Arts::Synth_MULTI_ADD";
}

bool Arts::Synth_MULTI_ADD_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_MULTI_ADD") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_MULTI_ADD_skel::_interfaceNameSkel()
{
	return "Arts::Synth_MULTI_ADD";
}

void Arts::Synth_MULTI_ADD_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_MULTI_ADD_skel::Synth_MULTI_ADD_skel()
{
	_initStream("invalue",&invalue,13);
	_initStream("outvalue",&outvalue,10);
}

Arts::Object_base* Arts::Synth_MULTI_ADD::_Creator() {
	return Arts::Synth_MULTI_ADD_base::_create();
}

unsigned long Arts::Synth_MULTI_ADD_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_MULTI_ADD");

Arts::Synth_ADD_base *Arts::Synth_ADD_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_ADD_base *castedObject = (Arts::Synth_ADD_base *)skel->_cast(Arts::Synth_ADD_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_ADD_base *Arts::Synth_ADD_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_ADD_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_ADD_base *Arts::Synth_ADD_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_ADD_base *castedObject = (Arts::Synth_ADD_base *)object._base()->_cast(Arts::Synth_ADD_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_ADD_base *Arts::Synth_ADD_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_ADD_base *result;
	result = (Arts::Synth_ADD_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_ADD");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_ADD_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_ADD")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_ADD_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("invalue1");
	ret.push_back("invalue2");
	return ret;
}
std::vector<std::string> Arts::Synth_ADD_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outvalue");
	return ret;
}

void *Arts::Synth_ADD_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_ADD_base::_IID) return (Arts::Synth_ADD_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_ADD_stub::Synth_ADD_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_ADD_stub::Synth_ADD_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_ADD_skel::_interfaceName()
{
	return "Arts::Synth_ADD";
}

bool Arts::Synth_ADD_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_ADD") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_ADD_skel::_interfaceNameSkel()
{
	return "Arts::Synth_ADD";
}

void Arts::Synth_ADD_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_ADD_skel::Synth_ADD_skel()
{
	_initStream("invalue1",&invalue1,73);
	_initStream("invalue2",&invalue2,73);
	_initStream("outvalue",&outvalue,10);
}

Arts::Object_base* Arts::Synth_ADD::_Creator() {
	return Arts::Synth_ADD_base::_create();
}

unsigned long Arts::Synth_ADD_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_ADD");

Arts::Synth_MUL_base *Arts::Synth_MUL_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_MUL_base *castedObject = (Arts::Synth_MUL_base *)skel->_cast(Arts::Synth_MUL_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_MUL_base *Arts::Synth_MUL_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_MUL_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_MUL_base *Arts::Synth_MUL_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_MUL_base *castedObject = (Arts::Synth_MUL_base *)object._base()->_cast(Arts::Synth_MUL_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_MUL_base *Arts::Synth_MUL_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_MUL_base *result;
	result = (Arts::Synth_MUL_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_MUL");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_MUL_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_MUL")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_MUL_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("invalue2");
	ret.push_back("invalue1");
	return ret;
}
std::vector<std::string> Arts::Synth_MUL_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outvalue");
	return ret;
}

void *Arts::Synth_MUL_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_MUL_base::_IID) return (Arts::Synth_MUL_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_MUL_stub::Synth_MUL_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_MUL_stub::Synth_MUL_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_MUL_skel::_interfaceName()
{
	return "Arts::Synth_MUL";
}

bool Arts::Synth_MUL_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_MUL") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_MUL_skel::_interfaceNameSkel()
{
	return "Arts::Synth_MUL";
}

void Arts::Synth_MUL_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_MUL_skel::Synth_MUL_skel()
{
	_initStream("invalue1",&invalue1,9);
	_initStream("invalue2",&invalue2,9);
	_initStream("outvalue",&outvalue,10);
}

Arts::Object_base* Arts::Synth_MUL::_Creator() {
	return Arts::Synth_MUL_base::_create();
}

unsigned long Arts::Synth_MUL_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_MUL");

Arts::Synth_PLAY_WAV_base *Arts::Synth_PLAY_WAV_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_PLAY_WAV_base *castedObject = (Arts::Synth_PLAY_WAV_base *)skel->_cast(Arts::Synth_PLAY_WAV_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_PLAY_WAV_base *Arts::Synth_PLAY_WAV_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_PLAY_WAV_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_PLAY_WAV_base *Arts::Synth_PLAY_WAV_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_PLAY_WAV_base *castedObject = (Arts::Synth_PLAY_WAV_base *)object._base()->_cast(Arts::Synth_PLAY_WAV_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_PLAY_WAV_base *Arts::Synth_PLAY_WAV_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_PLAY_WAV_base *result;
	result = (Arts::Synth_PLAY_WAV_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_PLAY_WAV");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_PLAY_WAV_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_PLAY_WAV")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_PLAY_WAV_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::Synth_PLAY_WAV_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("right");
	ret.push_back("left");
	return ret;
}

void *Arts::Synth_PLAY_WAV_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_PLAY_WAV_base::_IID) return (Arts::Synth_PLAY_WAV_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_PLAY_WAV_stub::Synth_PLAY_WAV_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_PLAY_WAV_stub::Synth_PLAY_WAV_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

float Arts::Synth_PLAY_WAV_stub::speed()
{
	long methodID = _lookupMethodFast("method:0000000b5f6765745f73706565640000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

void Arts::Synth_PLAY_WAV_stub::speed(float newValue)
{
	long methodID = _lookupMethodFast("method:0000000b5f7365745f73706565640000000005766f696400000000020000000100000006666c6f617400000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeFloat(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_PLAY_WAV_stub::filename()
{
	long methodID = _lookupMethodFast("method:0000000e5f6765745f66696c656e616d650000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::Synth_PLAY_WAV_stub::filename(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:0000000e5f7365745f66696c656e616d650000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

bool Arts::Synth_PLAY_WAV_stub::finished()
{
	long methodID = _lookupMethodFast("method:0000000e5f6765745f66696e69736865640000000008626f6f6c65616e00000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occurred
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

std::string Arts::Synth_PLAY_WAV_skel::_interfaceName()
{
	return "Arts::Synth_PLAY_WAV";
}

bool Arts::Synth_PLAY_WAV_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_PLAY_WAV") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_PLAY_WAV_skel::_interfaceNameSkel()
{
	return "Arts::Synth_PLAY_WAV";
}

// _get_speed
static void _dispatch_Arts_Synth_PLAY_WAV_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::Synth_PLAY_WAV_skel *)object)->speed());
}

// _set_speed
static void _dispatch_Arts_Synth_PLAY_WAV_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	float newValue = request->readFloat();
	((Arts::Synth_PLAY_WAV_skel *)object)->speed(newValue);
}

// _get_filename
static void _dispatch_Arts_Synth_PLAY_WAV_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Synth_PLAY_WAV_skel *)object)->filename());
}

// _set_filename
static void _dispatch_Arts_Synth_PLAY_WAV_03(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::Synth_PLAY_WAV_skel *)object)->filename(newValue);
}

// _get_finished
static void _dispatch_Arts_Synth_PLAY_WAV_04(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeBool(((Arts::Synth_PLAY_WAV_skel *)object)->finished());
}

void Arts::Synth_PLAY_WAV_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000b5f6765745f73706565640000000006666c6f6174000000"
        "000200000000000000000000000b5f7365745f73706565640000000005766f6964"
        "00000000020000000100000006666c6f617400000000096e657756616c75650000"
        "000000000000000000000e5f6765745f66696c656e616d65000000000773747269"
        "6e67000000000200000000000000000000000e5f7365745f66696c656e616d6500"
        "00000005766f696400000000020000000100000007737472696e6700000000096e"
        "657756616c75650000000000000000000000000e5f6765745f66696e6973686564"
        "0000000008626f6f6c65616e00000000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_Synth_PLAY_WAV_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_PLAY_WAV_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_PLAY_WAV_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_PLAY_WAV_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_PLAY_WAV_04,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_PLAY_WAV_skel::Synth_PLAY_WAV_skel()
{
	_initStream("left",&left,10);
	_initStream("right",&right,10);
}

Arts::Object_base* Arts::Synth_PLAY_WAV::_Creator() {
	return Arts::Synth_PLAY_WAV_base::_create();
}

unsigned long Arts::Synth_PLAY_WAV_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_PLAY_WAV");

Arts::Synth_BUS_UPLINK_base *Arts::Synth_BUS_UPLINK_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_BUS_UPLINK_base *castedObject = (Arts::Synth_BUS_UPLINK_base *)skel->_cast(Arts::Synth_BUS_UPLINK_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_BUS_UPLINK_base *Arts::Synth_BUS_UPLINK_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_BUS_UPLINK_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_BUS_UPLINK_base *Arts::Synth_BUS_UPLINK_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_BUS_UPLINK_base *castedObject = (Arts::Synth_BUS_UPLINK_base *)object._base()->_cast(Arts::Synth_BUS_UPLINK_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_BUS_UPLINK_base *Arts::Synth_BUS_UPLINK_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_BUS_UPLINK_base *result;
	result = (Arts::Synth_BUS_UPLINK_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_BUS_UPLINK");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_BUS_UPLINK_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_BUS_UPLINK")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_BUS_UPLINK_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("left");
	ret.push_back("right");
	return ret;
}
std::vector<std::string> Arts::Synth_BUS_UPLINK_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::Synth_BUS_UPLINK_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_BUS_UPLINK_base::_IID) return (Arts::Synth_BUS_UPLINK_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_BUS_UPLINK_stub::Synth_BUS_UPLINK_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_BUS_UPLINK_stub::Synth_BUS_UPLINK_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_BUS_UPLINK_stub::busname()
{
	long methodID = _lookupMethodFast("method:0000000d5f6765745f6275736e616d650000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::Synth_BUS_UPLINK_stub::busname(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:0000000d5f7365745f6275736e616d650000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_BUS_UPLINK_skel::_interfaceName()
{
	return "Arts::Synth_BUS_UPLINK";
}

bool Arts::Synth_BUS_UPLINK_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_BUS_UPLINK") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_BUS_UPLINK_skel::_interfaceNameSkel()
{
	return "Arts::Synth_BUS_UPLINK";
}

// _get_busname
static void _dispatch_Arts_Synth_BUS_UPLINK_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Synth_BUS_UPLINK_skel *)object)->busname());
}

// _set_busname
static void _dispatch_Arts_Synth_BUS_UPLINK_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::Synth_BUS_UPLINK_skel *)object)->busname(newValue);
}

void Arts::Synth_BUS_UPLINK_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000d5f6765745f6275736e616d650000000007737472696e67"
        "000000000200000000000000000000000d5f7365745f6275736e616d6500000000"
        "05766f696400000000020000000100000007737472696e6700000000096e657756"
        "616c7565000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_Synth_BUS_UPLINK_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_BUS_UPLINK_01,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_BUS_UPLINK_skel::Synth_BUS_UPLINK_skel()
{
	_initStream("left",&left,73);
	_initStream("right",&right,73);
}

Arts::Object_base* Arts::Synth_BUS_UPLINK::_Creator() {
	return Arts::Synth_BUS_UPLINK_base::_create();
}

unsigned long Arts::Synth_BUS_UPLINK_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_BUS_UPLINK");

Arts::Synth_BUS_DOWNLINK_base *Arts::Synth_BUS_DOWNLINK_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_BUS_DOWNLINK_base *castedObject = (Arts::Synth_BUS_DOWNLINK_base *)skel->_cast(Arts::Synth_BUS_DOWNLINK_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_BUS_DOWNLINK_base *Arts::Synth_BUS_DOWNLINK_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_BUS_DOWNLINK_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_BUS_DOWNLINK_base *Arts::Synth_BUS_DOWNLINK_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_BUS_DOWNLINK_base *castedObject = (Arts::Synth_BUS_DOWNLINK_base *)object._base()->_cast(Arts::Synth_BUS_DOWNLINK_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_BUS_DOWNLINK_base *Arts::Synth_BUS_DOWNLINK_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_BUS_DOWNLINK_base *result;
	result = (Arts::Synth_BUS_DOWNLINK_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_BUS_DOWNLINK");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_BUS_DOWNLINK_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_BUS_DOWNLINK")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_BUS_DOWNLINK_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::Synth_BUS_DOWNLINK_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("left");
	ret.push_back("right");
	return ret;
}

void *Arts::Synth_BUS_DOWNLINK_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_BUS_DOWNLINK_base::_IID) return (Arts::Synth_BUS_DOWNLINK_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_BUS_DOWNLINK_stub::Synth_BUS_DOWNLINK_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_BUS_DOWNLINK_stub::Synth_BUS_DOWNLINK_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::Synth_BUS_DOWNLINK_stub::busname()
{
	long methodID = _lookupMethodFast("method:0000000d5f6765745f6275736e616d650000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::Synth_BUS_DOWNLINK_stub::busname(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:0000000d5f7365745f6275736e616d650000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_BUS_DOWNLINK_skel::_interfaceName()
{
	return "Arts::Synth_BUS_DOWNLINK";
}

bool Arts::Synth_BUS_DOWNLINK_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_BUS_DOWNLINK") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_BUS_DOWNLINK_skel::_interfaceNameSkel()
{
	return "Arts::Synth_BUS_DOWNLINK";
}

// _get_busname
static void _dispatch_Arts_Synth_BUS_DOWNLINK_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Synth_BUS_DOWNLINK_skel *)object)->busname());
}

// _set_busname
static void _dispatch_Arts_Synth_BUS_DOWNLINK_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::Synth_BUS_DOWNLINK_skel *)object)->busname(newValue);
}

void Arts::Synth_BUS_DOWNLINK_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000d5f6765745f6275736e616d650000000007737472696e67"
        "000000000200000000000000000000000d5f7365745f6275736e616d6500000000"
        "05766f696400000000020000000100000007737472696e6700000000096e657756"
        "616c7565000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_Synth_BUS_DOWNLINK_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_BUS_DOWNLINK_01,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_BUS_DOWNLINK_skel::Synth_BUS_DOWNLINK_skel()
{
	_initStream("left",&left,74);
	_initStream("right",&right,74);
}

Arts::Object_base* Arts::Synth_BUS_DOWNLINK::_Creator() {
	return Arts::Synth_BUS_DOWNLINK_base::_create();
}

unsigned long Arts::Synth_BUS_DOWNLINK_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_BUS_DOWNLINK");

Arts::ByteStreamToAudio_base *Arts::ByteStreamToAudio_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::ByteStreamToAudio_base *castedObject = (Arts::ByteStreamToAudio_base *)skel->_cast(Arts::ByteStreamToAudio_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::ByteStreamToAudio_base *Arts::ByteStreamToAudio_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::ByteStreamToAudio_base::_fromReference(r,true);
	return 0;
}

Arts::ByteStreamToAudio_base *Arts::ByteStreamToAudio_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::ByteStreamToAudio_base *castedObject = (Arts::ByteStreamToAudio_base *)object._base()->_cast(Arts::ByteStreamToAudio_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::ByteStreamToAudio_base *Arts::ByteStreamToAudio_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::ByteStreamToAudio_base *result;
	result = (Arts::ByteStreamToAudio_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::ByteStreamToAudio");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::ByteStreamToAudio_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::ByteStreamToAudio")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::ByteStreamToAudio_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("indata");
	return ret;
}
std::vector<std::string> Arts::ByteStreamToAudio_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("left");
	ret.push_back("right");
	return ret;
}

void *Arts::ByteStreamToAudio_base::_cast(unsigned long iid)
{
	if(iid == Arts::ByteStreamToAudio_base::_IID) return (Arts::ByteStreamToAudio_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::ByteStreamToAudio_stub::ByteStreamToAudio_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::ByteStreamToAudio_stub::ByteStreamToAudio_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

long Arts::ByteStreamToAudio_stub::samplingRate()
{
	long methodID = _lookupMethodFast("method:000000125f6765745f73616d706c696e675261746500000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::ByteStreamToAudio_stub::samplingRate(long newValue)
{
	long methodID = _lookupMethodFast("method:000000125f7365745f73616d706c696e67526174650000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::ByteStreamToAudio_stub::channels()
{
	long methodID = _lookupMethodFast("method:0000000e5f6765745f6368616e6e656c7300000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::ByteStreamToAudio_stub::channels(long newValue)
{
	long methodID = _lookupMethodFast("method:0000000e5f7365745f6368616e6e656c730000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::ByteStreamToAudio_stub::bits()
{
	long methodID = _lookupMethodFast("method:0000000a5f6765745f6269747300000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::ByteStreamToAudio_stub::bits(long newValue)
{
	long methodID = _lookupMethodFast("method:0000000a5f7365745f626974730000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

bool Arts::ByteStreamToAudio_stub::running()
{
	long methodID = _lookupMethodFast("method:0000000d5f6765745f72756e6e696e670000000008626f6f6c65616e00000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occurred
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

std::string Arts::ByteStreamToAudio_skel::_interfaceName()
{
	return "Arts::ByteStreamToAudio";
}

bool Arts::ByteStreamToAudio_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::ByteStreamToAudio") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::ByteStreamToAudio_skel::_interfaceNameSkel()
{
	return "Arts::ByteStreamToAudio";
}

// _get_samplingRate
static void _dispatch_Arts_ByteStreamToAudio_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::ByteStreamToAudio_skel *)object)->samplingRate());
}

// _set_samplingRate
static void _dispatch_Arts_ByteStreamToAudio_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::ByteStreamToAudio_skel *)object)->samplingRate(newValue);
}

// _get_channels
static void _dispatch_Arts_ByteStreamToAudio_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::ByteStreamToAudio_skel *)object)->channels());
}

// _set_channels
static void _dispatch_Arts_ByteStreamToAudio_03(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::ByteStreamToAudio_skel *)object)->channels(newValue);
}

// _get_bits
static void _dispatch_Arts_ByteStreamToAudio_04(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::ByteStreamToAudio_skel *)object)->bits());
}

// _set_bits
static void _dispatch_Arts_ByteStreamToAudio_05(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::ByteStreamToAudio_skel *)object)->bits(newValue);
}

// _get_running
static void _dispatch_Arts_ByteStreamToAudio_06(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeBool(((Arts::ByteStreamToAudio_skel *)object)->running());
}

void Arts::ByteStreamToAudio_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:000000125f6765745f73616d706c696e675261746500000000056c"
        "6f6e6700000000020000000000000000000000125f7365745f73616d706c696e67"
        "526174650000000005766f6964000000000200000001000000056c6f6e67000000"
        "00096e657756616c75650000000000000000000000000e5f6765745f6368616e6e"
        "656c7300000000056c6f6e67000000000200000000000000000000000e5f736574"
        "5f6368616e6e656c730000000005766f6964000000000200000001000000056c6f"
        "6e6700000000096e657756616c75650000000000000000000000000a5f6765745f"
        "6269747300000000056c6f6e67000000000200000000000000000000000a5f7365"
        "745f626974730000000005766f6964000000000200000001000000056c6f6e6700"
        "000000096e657756616c75650000000000000000000000000d5f6765745f72756e"
        "6e696e670000000008626f6f6c65616e00000000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_ByteStreamToAudio_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_ByteStreamToAudio_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_ByteStreamToAudio_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_ByteStreamToAudio_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_ByteStreamToAudio_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_ByteStreamToAudio_05,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_ByteStreamToAudio_06,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::ByteStreamToAudio_skel::ByteStreamToAudio_skel()
{
	_initStream("indata",&indata,41);
	_initStream("left",&left,10);
	_initStream("right",&right,10);
}

void Arts::ByteStreamToAudio_skel::notify(const Arts::Notification &notification)
{
	if(indata.notifyID() == notification.ID)
		process_indata((Arts::DataPacket<Arts::mcopbyte> *)notification.data);
}

Arts::Object_base* Arts::ByteStreamToAudio::_Creator() {
	return Arts::ByteStreamToAudio_base::_create();
}

unsigned long Arts::ByteStreamToAudio_base::_IID = Arts::MCOPUtils::makeIID("Arts::ByteStreamToAudio");

Arts::AudioToByteStream_base *Arts::AudioToByteStream_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::AudioToByteStream_base *castedObject = (Arts::AudioToByteStream_base *)skel->_cast(Arts::AudioToByteStream_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::AudioToByteStream_base *Arts::AudioToByteStream_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::AudioToByteStream_base::_fromReference(r,true);
	return 0;
}

Arts::AudioToByteStream_base *Arts::AudioToByteStream_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::AudioToByteStream_base *castedObject = (Arts::AudioToByteStream_base *)object._base()->_cast(Arts::AudioToByteStream_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::AudioToByteStream_base *Arts::AudioToByteStream_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::AudioToByteStream_base *result;
	result = (Arts::AudioToByteStream_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::AudioToByteStream");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::AudioToByteStream_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::AudioToByteStream")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::AudioToByteStream_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("left");
	ret.push_back("right");
	return ret;
}
std::vector<std::string> Arts::AudioToByteStream_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outdata");
	return ret;
}

void *Arts::AudioToByteStream_base::_cast(unsigned long iid)
{
	if(iid == Arts::AudioToByteStream_base::_IID) return (Arts::AudioToByteStream_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::AudioToByteStream_stub::AudioToByteStream_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::AudioToByteStream_stub::AudioToByteStream_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

long Arts::AudioToByteStream_stub::samplingRate()
{
	long methodID = _lookupMethodFast("method:000000125f6765745f73616d706c696e675261746500000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::AudioToByteStream_stub::samplingRate(long newValue)
{
	long methodID = _lookupMethodFast("method:000000125f7365745f73616d706c696e67526174650000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::AudioToByteStream_stub::channels()
{
	long methodID = _lookupMethodFast("method:0000000e5f6765745f6368616e6e656c7300000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::AudioToByteStream_stub::channels(long newValue)
{
	long methodID = _lookupMethodFast("method:0000000e5f7365745f6368616e6e656c730000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::AudioToByteStream_stub::bits()
{
	long methodID = _lookupMethodFast("method:0000000a5f6765745f6269747300000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::AudioToByteStream_stub::bits(long newValue)
{
	long methodID = _lookupMethodFast("method:0000000a5f7365745f626974730000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::AudioToByteStream_skel::_interfaceName()
{
	return "Arts::AudioToByteStream";
}

bool Arts::AudioToByteStream_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::AudioToByteStream") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::AudioToByteStream_skel::_interfaceNameSkel()
{
	return "Arts::AudioToByteStream";
}

// _get_samplingRate
static void _dispatch_Arts_AudioToByteStream_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::AudioToByteStream_skel *)object)->samplingRate());
}

// _set_samplingRate
static void _dispatch_Arts_AudioToByteStream_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::AudioToByteStream_skel *)object)->samplingRate(newValue);
}

// _get_channels
static void _dispatch_Arts_AudioToByteStream_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::AudioToByteStream_skel *)object)->channels());
}

// _set_channels
static void _dispatch_Arts_AudioToByteStream_03(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::AudioToByteStream_skel *)object)->channels(newValue);
}

// _get_bits
static void _dispatch_Arts_AudioToByteStream_04(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::AudioToByteStream_skel *)object)->bits());
}

// _set_bits
static void _dispatch_Arts_AudioToByteStream_05(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::AudioToByteStream_skel *)object)->bits(newValue);
}

void Arts::AudioToByteStream_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:000000125f6765745f73616d706c696e675261746500000000056c"
        "6f6e6700000000020000000000000000000000125f7365745f73616d706c696e67"
        "526174650000000005766f6964000000000200000001000000056c6f6e67000000"
        "00096e657756616c75650000000000000000000000000e5f6765745f6368616e6e"
        "656c7300000000056c6f6e67000000000200000000000000000000000e5f736574"
        "5f6368616e6e656c730000000005766f6964000000000200000001000000056c6f"
        "6e6700000000096e657756616c75650000000000000000000000000a5f6765745f"
        "6269747300000000056c6f6e67000000000200000000000000000000000a5f7365"
        "745f626974730000000005766f6964000000000200000001000000056c6f6e6700"
        "000000096e657756616c7565000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_AudioToByteStream_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioToByteStream_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioToByteStream_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioToByteStream_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioToByteStream_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioToByteStream_05,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::AudioToByteStream_skel::AudioToByteStream_skel()
{
	_initStream("outdata",&outdata,42);
	_initStream("left",&left,9);
	_initStream("right",&right,9);
}

void Arts::AudioToByteStream_skel::notify(const Arts::Notification &notification)
{
	if(outdata.notifyID() == notification.ID)
		request_outdata((Arts::DataPacket<Arts::mcopbyte> *)notification.data);
}

void Arts::AudioToByteStream_skel::request_outdata(Arts::DataPacket<Arts::mcopbyte> *)
{
	assert(false); // this default is for modules who don't want requesting
}

Arts::Object_base* Arts::AudioToByteStream::_Creator() {
	return Arts::AudioToByteStream_base::_create();
}

unsigned long Arts::AudioToByteStream_base::_IID = Arts::MCOPUtils::makeIID("Arts::AudioToByteStream");

Arts::StereoEffect_base *Arts::StereoEffect_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::StereoEffect_base *castedObject = (Arts::StereoEffect_base *)skel->_cast(Arts::StereoEffect_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::StereoEffect_base *Arts::StereoEffect_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::StereoEffect_base::_fromReference(r,true);
	return 0;
}

Arts::StereoEffect_base *Arts::StereoEffect_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::StereoEffect_base *castedObject = (Arts::StereoEffect_base *)object._base()->_cast(Arts::StereoEffect_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::StereoEffect_base *Arts::StereoEffect_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::StereoEffect_base *result;
	result = (Arts::StereoEffect_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::StereoEffect");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::StereoEffect_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::StereoEffect")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::StereoEffect_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("inleft");
	ret.push_back("inright");
	return ret;
}
std::vector<std::string> Arts::StereoEffect_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outleft");
	ret.push_back("outright");
	return ret;
}

void *Arts::StereoEffect_base::_cast(unsigned long iid)
{
	if(iid == Arts::StereoEffect_base::_IID) return (Arts::StereoEffect_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::StereoEffect_stub::StereoEffect_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::StereoEffect_stub::StereoEffect_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::StereoEffect_skel::_interfaceName()
{
	return "Arts::StereoEffect";
}

bool Arts::StereoEffect_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::StereoEffect") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::StereoEffect_skel::_interfaceNameSkel()
{
	return "Arts::StereoEffect";
}

void Arts::StereoEffect_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::StereoEffect_skel::StereoEffect_skel()
{
	_initStream("inleft",&inleft,73);
	_initStream("inright",&inright,73);
	_initStream("outleft",&outleft,74);
	_initStream("outright",&outright,74);
}

Arts::Object_base* Arts::StereoEffect::_Creator() {
	return Arts::StereoEffect_base::_create();
}

unsigned long Arts::StereoEffect_base::_IID = Arts::MCOPUtils::makeIID("Arts::StereoEffect");

Arts::StereoVolumeControl_base *Arts::StereoVolumeControl_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::StereoVolumeControl_base *castedObject = (Arts::StereoVolumeControl_base *)skel->_cast(Arts::StereoVolumeControl_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::StereoVolumeControl_base *Arts::StereoVolumeControl_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::StereoVolumeControl_base::_fromReference(r,true);
	return 0;
}

Arts::StereoVolumeControl_base *Arts::StereoVolumeControl_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::StereoVolumeControl_base *castedObject = (Arts::StereoVolumeControl_base *)object._base()->_cast(Arts::StereoVolumeControl_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::StereoVolumeControl_base *Arts::StereoVolumeControl_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::StereoVolumeControl_base *result;
	result = (Arts::StereoVolumeControl_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::StereoVolumeControl");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::StereoVolumeControl_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::StereoVolumeControl")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::StereoVolumeControl_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("inleft");
	ret.push_back("inright");
	return ret;
}
std::vector<std::string> Arts::StereoVolumeControl_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outleft");
	ret.push_back("outright");
	return ret;
}

void *Arts::StereoVolumeControl_base::_cast(unsigned long iid)
{
	if(iid == Arts::StereoVolumeControl_base::_IID) return (Arts::StereoVolumeControl_base *)this;
	if(iid == Arts::StereoEffect_base::_IID) return (Arts::StereoEffect_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::StereoVolumeControl_stub::StereoVolumeControl_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::StereoVolumeControl_stub::StereoVolumeControl_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

float Arts::StereoVolumeControl_stub::scaleFactor()
{
	long methodID = _lookupMethodFast("method:000000115f6765745f7363616c65466163746f720000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

void Arts::StereoVolumeControl_stub::scaleFactor(float newValue)
{
	long methodID = _lookupMethodFast("method:000000115f7365745f7363616c65466163746f720000000005766f696400000000020000000100000006666c6f617400000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeFloat(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

float Arts::StereoVolumeControl_stub::currentVolumeLeft()
{
	long methodID = _lookupMethodFast("method:000000175f6765745f63757272656e74566f6c756d654c6566740000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

float Arts::StereoVolumeControl_stub::currentVolumeRight()
{
	long methodID = _lookupMethodFast("method:000000185f6765745f63757272656e74566f6c756d6552696768740000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

std::string Arts::StereoVolumeControl_skel::_interfaceName()
{
	return "Arts::StereoVolumeControl";
}

bool Arts::StereoVolumeControl_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::StereoVolumeControl") return true;
	if (interfacename == "Arts::StereoEffect") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::StereoVolumeControl_skel::_interfaceNameSkel()
{
	return "Arts::StereoVolumeControl";
}

// _get_scaleFactor
static void _dispatch_Arts_StereoVolumeControl_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::StereoVolumeControl_skel *)object)->scaleFactor());
}

// _set_scaleFactor
static void _dispatch_Arts_StereoVolumeControl_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	float newValue = request->readFloat();
	((Arts::StereoVolumeControl_skel *)object)->scaleFactor(newValue);
}

// _get_currentVolumeLeft
static void _dispatch_Arts_StereoVolumeControl_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::StereoVolumeControl_skel *)object)->currentVolumeLeft());
}

// _get_currentVolumeRight
static void _dispatch_Arts_StereoVolumeControl_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::StereoVolumeControl_skel *)object)->currentVolumeRight());
}

void Arts::StereoVolumeControl_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:000000115f6765745f7363616c65466163746f720000000006666c"
        "6f617400000000020000000000000000000000115f7365745f7363616c65466163"
        "746f720000000005766f696400000000020000000100000006666c6f6174000000"
        "00096e657756616c7565000000000000000000000000175f6765745f6375727265"
        "6e74566f6c756d654c6566740000000006666c6f61740000000002000000000000"
        "0000000000185f6765745f63757272656e74566f6c756d65526967687400000000"
        "06666c6f617400000000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_StereoVolumeControl_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_StereoVolumeControl_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_StereoVolumeControl_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_StereoVolumeControl_03,this,Arts::MethodDef(m));
	Arts::StereoEffect_skel::_buildMethodTable();
}

Arts::StereoVolumeControl_skel::StereoVolumeControl_skel()
{
}

Arts::Object_base* Arts::StereoVolumeControl::_Creator() {
	return Arts::StereoVolumeControl_base::_create();
}

unsigned long Arts::StereoVolumeControl_base::_IID = Arts::MCOPUtils::makeIID("Arts::StereoVolumeControl");

Arts::StereoFFTScope_base *Arts::StereoFFTScope_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::StereoFFTScope_base *castedObject = (Arts::StereoFFTScope_base *)skel->_cast(Arts::StereoFFTScope_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::StereoFFTScope_base *Arts::StereoFFTScope_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::StereoFFTScope_base::_fromReference(r,true);
	return 0;
}

Arts::StereoFFTScope_base *Arts::StereoFFTScope_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::StereoFFTScope_base *castedObject = (Arts::StereoFFTScope_base *)object._base()->_cast(Arts::StereoFFTScope_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::StereoFFTScope_base *Arts::StereoFFTScope_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::StereoFFTScope_base *result;
	result = (Arts::StereoFFTScope_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::StereoFFTScope");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::StereoFFTScope_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::StereoFFTScope")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::StereoFFTScope_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("inleft");
	ret.push_back("inright");
	return ret;
}
std::vector<std::string> Arts::StereoFFTScope_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outleft");
	ret.push_back("outright");
	return ret;
}

void *Arts::StereoFFTScope_base::_cast(unsigned long iid)
{
	if(iid == Arts::StereoFFTScope_base::_IID) return (Arts::StereoFFTScope_base *)this;
	if(iid == Arts::StereoEffect_base::_IID) return (Arts::StereoEffect_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::StereoFFTScope_stub::StereoFFTScope_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::StereoFFTScope_stub::StereoFFTScope_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::vector<float> * Arts::StereoFFTScope_stub::scope()
{
	long methodID = _lookupMethodFast("method:0000000b5f6765745f73636f706500000000072a666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<float> *_returnCode = new std::vector<float>;
	if(!result) return _returnCode; // error occurred
	result->readFloatSeq(*_returnCode);
	delete result;
	return _returnCode;
}

std::string Arts::StereoFFTScope_skel::_interfaceName()
{
	return "Arts::StereoFFTScope";
}

bool Arts::StereoFFTScope_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::StereoFFTScope") return true;
	if (interfacename == "Arts::StereoEffect") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::StereoFFTScope_skel::_interfaceNameSkel()
{
	return "Arts::StereoFFTScope";
}

// _get_scope
static void _dispatch_Arts_StereoFFTScope_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<float> *_returnCode = ((Arts::StereoFFTScope_skel *)object)->scope();
	result->writeFloatSeq(*_returnCode);
	delete _returnCode;
}

void Arts::StereoFFTScope_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000b5f6765745f73636f706500000000072a666c6f61740000"
        "0000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_StereoFFTScope_00,this,Arts::MethodDef(m));
	Arts::StereoEffect_skel::_buildMethodTable();
}

Arts::StereoFFTScope_skel::StereoFFTScope_skel()
{
}

Arts::Object_base* Arts::StereoFFTScope::_Creator() {
	return Arts::StereoFFTScope_base::_create();
}

unsigned long Arts::StereoFFTScope_base::_IID = Arts::MCOPUtils::makeIID("Arts::StereoFFTScope");

Arts::StereoEffectStack_base *Arts::StereoEffectStack_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::StereoEffectStack_base *castedObject = (Arts::StereoEffectStack_base *)skel->_cast(Arts::StereoEffectStack_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::StereoEffectStack_base *Arts::StereoEffectStack_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::StereoEffectStack_base::_fromReference(r,true);
	return 0;
}

Arts::StereoEffectStack_base *Arts::StereoEffectStack_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::StereoEffectStack_base *castedObject = (Arts::StereoEffectStack_base *)object._base()->_cast(Arts::StereoEffectStack_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::StereoEffectStack_base *Arts::StereoEffectStack_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::StereoEffectStack_base *result;
	result = (Arts::StereoEffectStack_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::StereoEffectStack");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::StereoEffectStack_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::StereoEffectStack")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::StereoEffectStack_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("inleft");
	ret.push_back("inright");
	return ret;
}
std::vector<std::string> Arts::StereoEffectStack_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outleft");
	ret.push_back("outright");
	return ret;
}

void *Arts::StereoEffectStack_base::_cast(unsigned long iid)
{
	if(iid == Arts::StereoEffectStack_base::_IID) return (Arts::StereoEffectStack_base *)this;
	if(iid == Arts::StereoEffect_base::_IID) return (Arts::StereoEffect_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::StereoEffectStack_stub::StereoEffectStack_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::StereoEffectStack_stub::StereoEffectStack_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

long Arts::StereoEffectStack_stub::insertTop(Arts::StereoEffect effect, const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000a696e73657274546f7000000000056c6f6e6700000000020000000200000013417274733a3a53746572656f4566666563740000000007656666656374000000000000000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,effect._base());
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

long Arts::StereoEffectStack_stub::insertBottom(Arts::StereoEffect effect, const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000d696e73657274426f74746f6d00000000056c6f6e6700000000020000000200000013417274733a3a53746572656f4566666563740000000007656666656374000000000000000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,effect._base());
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::StereoEffectStack_stub::remove(long ID)
{
	long methodID = _lookupMethodFast("method:0000000772656d6f76650000000005766f6964000000000200000001000000056c6f6e6700000000034944000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(ID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::StereoEffectStack_skel::_interfaceName()
{
	return "Arts::StereoEffectStack";
}

bool Arts::StereoEffectStack_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::StereoEffectStack") return true;
	if (interfacename == "Arts::StereoEffect") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::StereoEffectStack_skel::_interfaceNameSkel()
{
	return "Arts::StereoEffectStack";
}

// insertTop
static void _dispatch_Arts_StereoEffectStack_00(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	Arts::StereoEffect_base* _temp_effect;
	Arts::readObject(*request,_temp_effect);
	Arts::StereoEffect effect = Arts::StereoEffect::_from_base(_temp_effect);
	std::string name;
	request->readString(name);
	result->writeLong(((Arts::StereoEffectStack_skel *)object)->insertTop(effect,name));
}

// insertBottom
static void _dispatch_Arts_StereoEffectStack_01(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	Arts::StereoEffect_base* _temp_effect;
	Arts::readObject(*request,_temp_effect);
	Arts::StereoEffect effect = Arts::StereoEffect::_from_base(_temp_effect);
	std::string name;
	request->readString(name);
	result->writeLong(((Arts::StereoEffectStack_skel *)object)->insertBottom(effect,name));
}

// remove
static void _dispatch_Arts_StereoEffectStack_02(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long ID = request->readLong();
	((Arts::StereoEffectStack_skel *)object)->remove(ID);
}

void Arts::StereoEffectStack_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000a696e73657274546f7000000000056c6f6e670000000002"
        "0000000200000013417274733a3a53746572656f45666665637400000000076566"
        "66656374000000000000000007737472696e6700000000056e616d650000000000"
        "000000000000000d696e73657274426f74746f6d00000000056c6f6e6700000000"
        "020000000200000013417274733a3a53746572656f456666656374000000000765"
        "6666656374000000000000000007737472696e6700000000056e616d6500000000"
        "00000000000000000772656d6f76650000000005766f6964000000000200000001"
        "000000056c6f6e6700000000034944000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_StereoEffectStack_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_StereoEffectStack_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_StereoEffectStack_02,this,Arts::MethodDef(m));
	Arts::StereoEffect_skel::_buildMethodTable();
}

Arts::StereoEffectStack_skel::StereoEffectStack_skel()
{
}

Arts::Object_base* Arts::StereoEffectStack::_Creator() {
	return Arts::StereoEffectStack_base::_create();
}

unsigned long Arts::StereoEffectStack_base::_IID = Arts::MCOPUtils::makeIID("Arts::StereoEffectStack");

Arts::AudioManagerClient_base *Arts::AudioManagerClient_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::AudioManagerClient_base *castedObject = (Arts::AudioManagerClient_base *)skel->_cast(Arts::AudioManagerClient_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::AudioManagerClient_base *Arts::AudioManagerClient_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::AudioManagerClient_base::_fromReference(r,true);
	return 0;
}

Arts::AudioManagerClient_base *Arts::AudioManagerClient_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::AudioManagerClient_base *castedObject = (Arts::AudioManagerClient_base *)object._base()->_cast(Arts::AudioManagerClient_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::AudioManagerClient_base *Arts::AudioManagerClient_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::AudioManagerClient_base *result;
	result = (Arts::AudioManagerClient_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::AudioManagerClient");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::AudioManagerClient_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::AudioManagerClient")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::AudioManagerClient_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::AudioManagerClient_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::AudioManagerClient_base::_cast(unsigned long iid)
{
	if(iid == Arts::AudioManagerClient_base::_IID) return (Arts::AudioManagerClient_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::AudioManagerClient_stub::AudioManagerClient_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::AudioManagerClient_stub::AudioManagerClient_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::AudioManagerClient_stub::constructor(Arts::AudioManagerDirection direction, const std::string& title, const std::string& autoRestoreID)
{
	long methodID = _lookupMethodFast("method:0000000c636f6e7374727563746f720000000005766f69640000000002000000030000001c417274733a3a417564696f4d616e61676572446972656374696f6e000000000a646972656374696f6e000000000000000007737472696e6700000000067469746c65000000000000000007737472696e67000000000e6175746f526573746f72654944000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(direction);
	request->writeString(title);
	request->writeString(autoRestoreID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::AudioManagerClient_stub::ID()
{
	long methodID = _lookupMethodFast("method:000000085f6765745f494400000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

Arts::AudioManagerDirection Arts::AudioManagerClient_stub::direction()
{
	long methodID = _lookupMethodFast("method:0000000f5f6765745f646972656374696f6e000000001c417274733a3a417564696f4d616e61676572446972656374696f6e00000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return (Arts::AudioManagerDirection)0; // error occurred
	Arts::AudioManagerDirection returnCode = (Arts::AudioManagerDirection)result->readLong();
	delete result;
	return returnCode;
}

void Arts::AudioManagerClient_stub::direction(Arts::AudioManagerDirection newValue)
{
	long methodID = _lookupMethodFast("method:0000000f5f7365745f646972656374696f6e0000000005766f69640000000002000000010000001c417274733a3a417564696f4d616e61676572446972656374696f6e00000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::AudioManagerClient_stub::title()
{
	long methodID = _lookupMethodFast("method:0000000b5f6765745f7469746c650000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::AudioManagerClient_stub::title(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:0000000b5f7365745f7469746c650000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::AudioManagerClient_stub::autoRestoreID()
{
	long methodID = _lookupMethodFast("method:000000135f6765745f6175746f526573746f726549440000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::AudioManagerClient_stub::autoRestoreID(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:000000135f7365745f6175746f526573746f726549440000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::AudioManagerClient_skel::_interfaceName()
{
	return "Arts::AudioManagerClient";
}

bool Arts::AudioManagerClient_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::AudioManagerClient") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::AudioManagerClient_skel::_interfaceNameSkel()
{
	return "Arts::AudioManagerClient";
}

// constructor
static void _dispatch_Arts_AudioManagerClient_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::AudioManagerDirection direction = (Arts::AudioManagerDirection)request->readLong();
	std::string title;
	request->readString(title);
	std::string autoRestoreID;
	request->readString(autoRestoreID);
	((Arts::AudioManagerClient_skel *)object)->constructor(direction,title,autoRestoreID);
}

// _get_ID
static void _dispatch_Arts_AudioManagerClient_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::AudioManagerClient_skel *)object)->ID());
}

// _get_direction
static void _dispatch_Arts_AudioManagerClient_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::AudioManagerClient_skel *)object)->direction());
}

// _set_direction
static void _dispatch_Arts_AudioManagerClient_03(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::AudioManagerDirection newValue = (Arts::AudioManagerDirection)request->readLong();
	((Arts::AudioManagerClient_skel *)object)->direction(newValue);
}

// _get_title
static void _dispatch_Arts_AudioManagerClient_04(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::AudioManagerClient_skel *)object)->title());
}

// _set_title
static void _dispatch_Arts_AudioManagerClient_05(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::AudioManagerClient_skel *)object)->title(newValue);
}

// _get_autoRestoreID
static void _dispatch_Arts_AudioManagerClient_06(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::AudioManagerClient_skel *)object)->autoRestoreID());
}

// _set_autoRestoreID
static void _dispatch_Arts_AudioManagerClient_07(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::AudioManagerClient_skel *)object)->autoRestoreID(newValue);
}

void Arts::AudioManagerClient_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000c636f6e7374727563746f720000000005766f6964000000"
        "0002000000030000001c417274733a3a417564696f4d616e616765724469726563"
        "74696f6e000000000a646972656374696f6e000000000000000007737472696e67"
        "00000000067469746c65000000000000000007737472696e67000000000e617574"
        "6f526573746f72654944000000000000000000000000085f6765745f4944000000"
        "00056c6f6e67000000000200000000000000000000000f5f6765745f6469726563"
        "74696f6e000000001c417274733a3a417564696f4d616e61676572446972656374"
        "696f6e000000000200000000000000000000000f5f7365745f646972656374696f"
        "6e0000000005766f69640000000002000000010000001c417274733a3a41756469"
        "6f4d616e61676572446972656374696f6e00000000096e657756616c7565000000"
        "0000000000000000000b5f6765745f7469746c650000000007737472696e670000"
        "00000200000000000000000000000b5f7365745f7469746c650000000005766f69"
        "6400000000020000000100000007737472696e6700000000096e657756616c7565"
        "000000000000000000000000135f6765745f6175746f526573746f726549440000"
        "000007737472696e6700000000020000000000000000000000135f7365745f6175"
        "746f526573746f726549440000000005766f696400000000020000000100000007"
        "737472696e6700000000096e657756616c7565000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_AudioManagerClient_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManagerClient_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManagerClient_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManagerClient_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManagerClient_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManagerClient_05,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManagerClient_06,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManagerClient_07,this,Arts::MethodDef(m));
}

Arts::AudioManagerClient_skel::AudioManagerClient_skel()
{
}

Arts::Object_base* Arts::AudioManagerClient::_Creator() {
	return Arts::AudioManagerClient_base::_create();
}

unsigned long Arts::AudioManagerClient_base::_IID = Arts::MCOPUtils::makeIID("Arts::AudioManagerClient");

Arts::AudioManager_base *Arts::AudioManager_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::AudioManager_base *castedObject = (Arts::AudioManager_base *)skel->_cast(Arts::AudioManager_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::AudioManager_base *Arts::AudioManager_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::AudioManager_base::_fromReference(r,true);
	return 0;
}

Arts::AudioManager_base *Arts::AudioManager_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::AudioManager_base *castedObject = (Arts::AudioManager_base *)object._base()->_cast(Arts::AudioManager_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::AudioManager_base *Arts::AudioManager_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::AudioManager_base *result;
	result = (Arts::AudioManager_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::AudioManager");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::AudioManager_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::AudioManager")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::AudioManager_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::AudioManager_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::AudioManager_base::_cast(unsigned long iid)
{
	if(iid == Arts::AudioManager_base::_IID) return (Arts::AudioManager_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::AudioManager_stub::AudioManager_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::AudioManager_stub::AudioManager_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::AudioManager_stub::setDestination(long ID, const std::string& destination)
{
	long methodID = _lookupMethodFast("method:0000000f73657444657374696e6174696f6e0000000005766f6964000000000200000002000000056c6f6e6700000000034944000000000000000007737472696e67000000000c64657374696e6174696f6e000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(ID);
	request->writeString(destination);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::vector<std::string> * Arts::AudioManager_stub::destinations()
{
	long methodID = _lookupMethodFast("method:000000125f6765745f64657374696e6174696f6e7300000000082a737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<std::string> *_returnCode = new std::vector<std::string>;
	if(!result) return _returnCode; // error occurred
	result->readStringSeq(*_returnCode);
	delete result;
	return _returnCode;
}

std::vector<Arts::AudioManagerInfo> * Arts::AudioManager_stub::clients()
{
	long methodID = _lookupMethodFast("method:0000000d5f6765745f636c69656e747300000000182a417274733a3a417564696f4d616e61676572496e666f00000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<Arts::AudioManagerInfo> *_returnCode = new std::vector<Arts::AudioManagerInfo>;
	if(!result) return _returnCode; // error occurred
	Arts::readTypeSeq(*result,*_returnCode);
	delete result;
	return _returnCode;
}

long Arts::AudioManager_stub::changes()
{
	long methodID = _lookupMethodFast("method:0000000d5f6765745f6368616e67657300000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

std::string Arts::AudioManager_skel::_interfaceName()
{
	return "Arts::AudioManager";
}

bool Arts::AudioManager_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::AudioManager") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::AudioManager_skel::_interfaceNameSkel()
{
	return "Arts::AudioManager";
}

// setDestination
static void _dispatch_Arts_AudioManager_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long ID = request->readLong();
	std::string destination;
	request->readString(destination);
	((Arts::AudioManager_skel *)object)->setDestination(ID,destination);
}

// _get_destinations
static void _dispatch_Arts_AudioManager_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<std::string> *_returnCode = ((Arts::AudioManager_skel *)object)->destinations();
	result->writeStringSeq(*_returnCode);
	delete _returnCode;
}

// _get_clients
static void _dispatch_Arts_AudioManager_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<Arts::AudioManagerInfo> *_returnCode = ((Arts::AudioManager_skel *)object)->clients();
	Arts::writeTypeSeq(*result,*_returnCode);
	delete _returnCode;
}

// _get_changes
static void _dispatch_Arts_AudioManager_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::AudioManager_skel *)object)->changes());
}

void Arts::AudioManager_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000f73657444657374696e6174696f6e0000000005766f6964"
        "000000000200000002000000056c6f6e6700000000034944000000000000000007"
        "737472696e67000000000c64657374696e6174696f6e0000000000000000000000"
        "00125f6765745f64657374696e6174696f6e7300000000082a737472696e670000"
        "00000200000000000000000000000d5f6765745f636c69656e747300000000182a"
        "417274733a3a417564696f4d616e61676572496e666f0000000002000000000000"
        "00000000000d5f6765745f6368616e67657300000000056c6f6e67000000000200"
        "00000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_AudioManager_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManager_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManager_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_AudioManager_03,this,Arts::MethodDef(m));
}

Arts::AudioManager_skel::AudioManager_skel()
{
}

Arts::Object_base* Arts::AudioManager::_Creator() {
	return Arts::AudioManager_base::_create();
}

unsigned long Arts::AudioManager_base::_IID = Arts::MCOPUtils::makeIID("Arts::AudioManager");

Arts::Synth_AMAN_PLAY_base *Arts::Synth_AMAN_PLAY_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_AMAN_PLAY_base *castedObject = (Arts::Synth_AMAN_PLAY_base *)skel->_cast(Arts::Synth_AMAN_PLAY_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_AMAN_PLAY_base *Arts::Synth_AMAN_PLAY_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_AMAN_PLAY_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_AMAN_PLAY_base *Arts::Synth_AMAN_PLAY_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_AMAN_PLAY_base *castedObject = (Arts::Synth_AMAN_PLAY_base *)object._base()->_cast(Arts::Synth_AMAN_PLAY_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_AMAN_PLAY_base *Arts::Synth_AMAN_PLAY_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_AMAN_PLAY_base *result;
	result = (Arts::Synth_AMAN_PLAY_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_AMAN_PLAY");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_AMAN_PLAY_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_AMAN_PLAY")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_AMAN_PLAY_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("left");
	ret.push_back("right");
	return ret;
}
std::vector<std::string> Arts::Synth_AMAN_PLAY_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::Synth_AMAN_PLAY_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_AMAN_PLAY_base::_IID) return (Arts::Synth_AMAN_PLAY_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_AMAN_PLAY_stub::Synth_AMAN_PLAY_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_AMAN_PLAY_stub::Synth_AMAN_PLAY_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::Synth_AMAN_PLAY_stub::constructor(Arts::AudioManagerClient client)
{
	long methodID = _lookupMethodFast("method:0000000c636f6e7374727563746f720000000005766f696400000000020000000100000019417274733a3a417564696f4d616e61676572436c69656e740000000007636c69656e74000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,client._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_AMAN_PLAY_stub::title()
{
	long methodID = _lookupMethodFast("method:0000000b5f6765745f7469746c650000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::Synth_AMAN_PLAY_stub::title(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:0000000b5f7365745f7469746c650000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_AMAN_PLAY_stub::autoRestoreID()
{
	long methodID = _lookupMethodFast("method:000000135f6765745f6175746f526573746f726549440000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::Synth_AMAN_PLAY_stub::autoRestoreID(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:000000135f7365745f6175746f526573746f726549440000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_AMAN_PLAY_skel::_interfaceName()
{
	return "Arts::Synth_AMAN_PLAY";
}

bool Arts::Synth_AMAN_PLAY_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_AMAN_PLAY") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_AMAN_PLAY_skel::_interfaceNameSkel()
{
	return "Arts::Synth_AMAN_PLAY";
}

// constructor
static void _dispatch_Arts_Synth_AMAN_PLAY_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::AudioManagerClient_base* _temp_client;
	Arts::readObject(*request,_temp_client);
	Arts::AudioManagerClient client = Arts::AudioManagerClient::_from_base(_temp_client);
	((Arts::Synth_AMAN_PLAY_skel *)object)->constructor(client);
}

// _get_title
static void _dispatch_Arts_Synth_AMAN_PLAY_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Synth_AMAN_PLAY_skel *)object)->title());
}

// _set_title
static void _dispatch_Arts_Synth_AMAN_PLAY_02(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::Synth_AMAN_PLAY_skel *)object)->title(newValue);
}

// _get_autoRestoreID
static void _dispatch_Arts_Synth_AMAN_PLAY_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Synth_AMAN_PLAY_skel *)object)->autoRestoreID());
}

// _set_autoRestoreID
static void _dispatch_Arts_Synth_AMAN_PLAY_04(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::Synth_AMAN_PLAY_skel *)object)->autoRestoreID(newValue);
}

void Arts::Synth_AMAN_PLAY_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000c636f6e7374727563746f720000000005766f6964000000"
        "00020000000100000019417274733a3a417564696f4d616e61676572436c69656e"
        "740000000007636c69656e740000000000000000000000000b5f6765745f746974"
        "6c650000000007737472696e67000000000200000000000000000000000b5f7365"
        "745f7469746c650000000005766f69640000000002000000010000000773747269"
        "6e6700000000096e657756616c7565000000000000000000000000135f6765745f"
        "6175746f526573746f726549440000000007737472696e67000000000200000000"
        "00000000000000135f7365745f6175746f526573746f726549440000000005766f"
        "696400000000020000000100000007737472696e6700000000096e657756616c75"
        "65000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_Synth_AMAN_PLAY_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_PLAY_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_PLAY_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_PLAY_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_PLAY_04,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_AMAN_PLAY_skel::Synth_AMAN_PLAY_skel()
{
	_initStream("left",&left,73);
	_initStream("right",&right,73);
}

Arts::Object_base* Arts::Synth_AMAN_PLAY::_Creator() {
	return Arts::Synth_AMAN_PLAY_base::_create();
}

unsigned long Arts::Synth_AMAN_PLAY_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_AMAN_PLAY");

Arts::Synth_AMAN_RECORD_base *Arts::Synth_AMAN_RECORD_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Synth_AMAN_RECORD_base *castedObject = (Arts::Synth_AMAN_RECORD_base *)skel->_cast(Arts::Synth_AMAN_RECORD_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Synth_AMAN_RECORD_base *Arts::Synth_AMAN_RECORD_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Synth_AMAN_RECORD_base::_fromReference(r,true);
	return 0;
}

Arts::Synth_AMAN_RECORD_base *Arts::Synth_AMAN_RECORD_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Synth_AMAN_RECORD_base *castedObject = (Arts::Synth_AMAN_RECORD_base *)object._base()->_cast(Arts::Synth_AMAN_RECORD_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Synth_AMAN_RECORD_base *Arts::Synth_AMAN_RECORD_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Synth_AMAN_RECORD_base *result;
	result = (Arts::Synth_AMAN_RECORD_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Synth_AMAN_RECORD");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Synth_AMAN_RECORD_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Synth_AMAN_RECORD")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Synth_AMAN_RECORD_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::Synth_AMAN_RECORD_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("left");
	ret.push_back("right");
	return ret;
}

void *Arts::Synth_AMAN_RECORD_base::_cast(unsigned long iid)
{
	if(iid == Arts::Synth_AMAN_RECORD_base::_IID) return (Arts::Synth_AMAN_RECORD_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Synth_AMAN_RECORD_stub::Synth_AMAN_RECORD_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Synth_AMAN_RECORD_stub::Synth_AMAN_RECORD_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::Synth_AMAN_RECORD_stub::constructor(Arts::AudioManagerClient client)
{
	long methodID = _lookupMethodFast("method:0000000c636f6e7374727563746f720000000005766f696400000000020000000100000019417274733a3a417564696f4d616e61676572436c69656e740000000007636c69656e74000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,client._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_AMAN_RECORD_stub::title()
{
	long methodID = _lookupMethodFast("method:0000000b5f6765745f7469746c650000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::Synth_AMAN_RECORD_stub::title(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:0000000b5f7365745f7469746c650000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_AMAN_RECORD_stub::autoRestoreID()
{
	long methodID = _lookupMethodFast("method:000000135f6765745f6175746f526573746f726549440000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occurred
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::Synth_AMAN_RECORD_stub::autoRestoreID(const std::string& newValue)
{
	long methodID = _lookupMethodFast("method:000000135f7365745f6175746f526573746f726549440000000005766f696400000000020000000100000007737472696e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::Synth_AMAN_RECORD_skel::_interfaceName()
{
	return "Arts::Synth_AMAN_RECORD";
}

bool Arts::Synth_AMAN_RECORD_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Synth_AMAN_RECORD") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Synth_AMAN_RECORD_skel::_interfaceNameSkel()
{
	return "Arts::Synth_AMAN_RECORD";
}

// constructor
static void _dispatch_Arts_Synth_AMAN_RECORD_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::AudioManagerClient_base* _temp_client;
	Arts::readObject(*request,_temp_client);
	Arts::AudioManagerClient client = Arts::AudioManagerClient::_from_base(_temp_client);
	((Arts::Synth_AMAN_RECORD_skel *)object)->constructor(client);
}

// _get_title
static void _dispatch_Arts_Synth_AMAN_RECORD_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Synth_AMAN_RECORD_skel *)object)->title());
}

// _set_title
static void _dispatch_Arts_Synth_AMAN_RECORD_02(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::Synth_AMAN_RECORD_skel *)object)->title(newValue);
}

// _get_autoRestoreID
static void _dispatch_Arts_Synth_AMAN_RECORD_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Synth_AMAN_RECORD_skel *)object)->autoRestoreID());
}

// _set_autoRestoreID
static void _dispatch_Arts_Synth_AMAN_RECORD_04(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string newValue;
	request->readString(newValue);
	((Arts::Synth_AMAN_RECORD_skel *)object)->autoRestoreID(newValue);
}

void Arts::Synth_AMAN_RECORD_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000c636f6e7374727563746f720000000005766f6964000000"
        "00020000000100000019417274733a3a417564696f4d616e61676572436c69656e"
        "740000000007636c69656e740000000000000000000000000b5f6765745f746974"
        "6c650000000007737472696e67000000000200000000000000000000000b5f7365"
        "745f7469746c650000000005766f69640000000002000000010000000773747269"
        "6e6700000000096e657756616c7565000000000000000000000000135f6765745f"
        "6175746f526573746f726549440000000007737472696e67000000000200000000"
        "00000000000000135f7365745f6175746f526573746f726549440000000005766f"
        "696400000000020000000100000007737472696e6700000000096e657756616c75"
        "65000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_Synth_AMAN_RECORD_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_RECORD_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_RECORD_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_RECORD_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Synth_AMAN_RECORD_04,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::Synth_AMAN_RECORD_skel::Synth_AMAN_RECORD_skel()
{
	_initStream("left",&left,74);
	_initStream("right",&right,74);
}

Arts::Object_base* Arts::Synth_AMAN_RECORD::_Creator() {
	return Arts::Synth_AMAN_RECORD_base::_create();
}

unsigned long Arts::Synth_AMAN_RECORD_base::_IID = Arts::MCOPUtils::makeIID("Arts::Synth_AMAN_RECORD");

Arts::DataHandle_base *Arts::DataHandle_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::DataHandle_base *castedObject = (Arts::DataHandle_base *)skel->_cast(Arts::DataHandle_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::DataHandle_base *Arts::DataHandle_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::DataHandle_base::_fromReference(r,true);
	return 0;
}

Arts::DataHandle_base *Arts::DataHandle_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::DataHandle_base *castedObject = (Arts::DataHandle_base *)object._base()->_cast(Arts::DataHandle_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::DataHandle_base *Arts::DataHandle_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::DataHandle_base *result;
	result = (Arts::DataHandle_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::DataHandle");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::DataHandle_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::DataHandle")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::DataHandle_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::DataHandle_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::DataHandle_base::_cast(unsigned long iid)
{
	if(iid == Arts::DataHandle_base::_IID) return (Arts::DataHandle_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::DataHandle_stub::DataHandle_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::DataHandle_stub::DataHandle_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

long Arts::DataHandle_stub::bitDepth()
{
	long methodID = _lookupMethodFast("method:0000000e5f6765745f626974446570746800000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

long Arts::DataHandle_stub::channelCount()
{
	long methodID = _lookupMethodFast("method:000000125f6765745f6368616e6e656c436f756e7400000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

long Arts::DataHandle_stub::valueCount()
{
	long methodID = _lookupMethodFast("method:000000105f6765745f76616c7565436f756e7400000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

long Arts::DataHandle_stub::errorNo()
{
	long methodID = _lookupMethodFast("method:0000000d5f6765745f6572726f724e6f00000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

std::string Arts::DataHandle_skel::_interfaceName()
{
	return "Arts::DataHandle";
}

bool Arts::DataHandle_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::DataHandle") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::DataHandle_skel::_interfaceNameSkel()
{
	return "Arts::DataHandle";
}

// _get_bitDepth
static void _dispatch_Arts_DataHandle_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::DataHandle_skel *)object)->bitDepth());
}

// _get_channelCount
static void _dispatch_Arts_DataHandle_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::DataHandle_skel *)object)->channelCount());
}

// _get_valueCount
static void _dispatch_Arts_DataHandle_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::DataHandle_skel *)object)->valueCount());
}

// _get_errorNo
static void _dispatch_Arts_DataHandle_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::DataHandle_skel *)object)->errorNo());
}

void Arts::DataHandle_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000e5f6765745f626974446570746800000000056c6f6e6700"
        "000000020000000000000000000000125f6765745f6368616e6e656c436f756e74"
        "00000000056c6f6e6700000000020000000000000000000000105f6765745f7661"
        "6c7565436f756e7400000000056c6f6e6700000000020000000000000000000000"
        "0d5f6765745f6572726f724e6f00000000056c6f6e670000000002000000000000"
        "0000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_DataHandle_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandle_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandle_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandle_03,this,Arts::MethodDef(m));
}

Arts::DataHandle_skel::DataHandle_skel()
{
}

Arts::Object_base* Arts::DataHandle::_Creator() {
	return Arts::DataHandle_base::_create();
}

unsigned long Arts::DataHandle_base::_IID = Arts::MCOPUtils::makeIID("Arts::DataHandle");

Arts::ReversedDataHandle_base *Arts::ReversedDataHandle_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::ReversedDataHandle_base *castedObject = (Arts::ReversedDataHandle_base *)skel->_cast(Arts::ReversedDataHandle_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::ReversedDataHandle_base *Arts::ReversedDataHandle_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::ReversedDataHandle_base::_fromReference(r,true);
	return 0;
}

Arts::ReversedDataHandle_base *Arts::ReversedDataHandle_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::ReversedDataHandle_base *castedObject = (Arts::ReversedDataHandle_base *)object._base()->_cast(Arts::ReversedDataHandle_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::ReversedDataHandle_base *Arts::ReversedDataHandle_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::ReversedDataHandle_base *result;
	result = (Arts::ReversedDataHandle_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::ReversedDataHandle");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::ReversedDataHandle_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::ReversedDataHandle")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::ReversedDataHandle_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::ReversedDataHandle_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::ReversedDataHandle_base::_cast(unsigned long iid)
{
	if(iid == Arts::ReversedDataHandle_base::_IID) return (Arts::ReversedDataHandle_base *)this;
	if(iid == Arts::DataHandle_base::_IID) return (Arts::DataHandle_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::ReversedDataHandle_stub::ReversedDataHandle_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::ReversedDataHandle_stub::ReversedDataHandle_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::ReversedDataHandle_stub::init(Arts::DataHandle sourceHandle)
{
	long methodID = _lookupMethodFast("method:00000005696e69740000000005766f696400000000020000000100000011417274733a3a4461746148616e646c65000000000d736f7572636548616e646c65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,sourceHandle._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::ReversedDataHandle_skel::_interfaceName()
{
	return "Arts::ReversedDataHandle";
}

bool Arts::ReversedDataHandle_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::ReversedDataHandle") return true;
	if (interfacename == "Arts::DataHandle") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::ReversedDataHandle_skel::_interfaceNameSkel()
{
	return "Arts::ReversedDataHandle";
}

// init
static void _dispatch_Arts_ReversedDataHandle_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::DataHandle_base* _temp_sourceHandle;
	Arts::readObject(*request,_temp_sourceHandle);
	Arts::DataHandle sourceHandle = Arts::DataHandle::_from_base(_temp_sourceHandle);
	((Arts::ReversedDataHandle_skel *)object)->init(sourceHandle);
}

void Arts::ReversedDataHandle_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:00000005696e69740000000005766f696400000000020000000100"
        "000011417274733a3a4461746148616e646c65000000000d736f7572636548616e"
        "646c65000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_ReversedDataHandle_00,this,Arts::MethodDef(m));
	Arts::DataHandle_skel::_buildMethodTable();
}

Arts::ReversedDataHandle_skel::ReversedDataHandle_skel()
{
}

Arts::Object_base* Arts::ReversedDataHandle::_Creator() {
	return Arts::ReversedDataHandle_base::_create();
}

unsigned long Arts::ReversedDataHandle_base::_IID = Arts::MCOPUtils::makeIID("Arts::ReversedDataHandle");

Arts::CroppedDataHandle_base *Arts::CroppedDataHandle_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::CroppedDataHandle_base *castedObject = (Arts::CroppedDataHandle_base *)skel->_cast(Arts::CroppedDataHandle_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::CroppedDataHandle_base *Arts::CroppedDataHandle_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::CroppedDataHandle_base::_fromReference(r,true);
	return 0;
}

Arts::CroppedDataHandle_base *Arts::CroppedDataHandle_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::CroppedDataHandle_base *castedObject = (Arts::CroppedDataHandle_base *)object._base()->_cast(Arts::CroppedDataHandle_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::CroppedDataHandle_base *Arts::CroppedDataHandle_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::CroppedDataHandle_base *result;
	result = (Arts::CroppedDataHandle_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::CroppedDataHandle");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::CroppedDataHandle_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::CroppedDataHandle")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::CroppedDataHandle_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::CroppedDataHandle_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::CroppedDataHandle_base::_cast(unsigned long iid)
{
	if(iid == Arts::CroppedDataHandle_base::_IID) return (Arts::CroppedDataHandle_base *)this;
	if(iid == Arts::DataHandle_base::_IID) return (Arts::DataHandle_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::CroppedDataHandle_stub::CroppedDataHandle_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::CroppedDataHandle_stub::CroppedDataHandle_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::CroppedDataHandle_stub::init(Arts::DataHandle sourceHandle, long headCutValueCount, long tailCutValueCount)
{
	long methodID = _lookupMethodFast("method:00000005696e69740000000005766f696400000000020000000300000011417274733a3a4461746148616e646c65000000000d736f7572636548616e646c650000000000000000056c6f6e6700000000126865616443757456616c7565436f756e740000000000000000056c6f6e6700000000127461696c43757456616c7565436f756e74000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,sourceHandle._base());
	request->writeLong(headCutValueCount);
	request->writeLong(tailCutValueCount);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::CroppedDataHandle_skel::_interfaceName()
{
	return "Arts::CroppedDataHandle";
}

bool Arts::CroppedDataHandle_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::CroppedDataHandle") return true;
	if (interfacename == "Arts::DataHandle") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::CroppedDataHandle_skel::_interfaceNameSkel()
{
	return "Arts::CroppedDataHandle";
}

// init
static void _dispatch_Arts_CroppedDataHandle_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::DataHandle_base* _temp_sourceHandle;
	Arts::readObject(*request,_temp_sourceHandle);
	Arts::DataHandle sourceHandle = Arts::DataHandle::_from_base(_temp_sourceHandle);
	long headCutValueCount = request->readLong();
	long tailCutValueCount = request->readLong();
	((Arts::CroppedDataHandle_skel *)object)->init(sourceHandle,headCutValueCount,tailCutValueCount);
}

void Arts::CroppedDataHandle_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:00000005696e69740000000005766f696400000000020000000300"
        "000011417274733a3a4461746148616e646c65000000000d736f7572636548616e"
        "646c650000000000000000056c6f6e6700000000126865616443757456616c7565"
        "436f756e740000000000000000056c6f6e6700000000127461696c43757456616c"
        "7565436f756e74000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_CroppedDataHandle_00,this,Arts::MethodDef(m));
	Arts::DataHandle_skel::_buildMethodTable();
}

Arts::CroppedDataHandle_skel::CroppedDataHandle_skel()
{
}

Arts::Object_base* Arts::CroppedDataHandle::_Creator() {
	return Arts::CroppedDataHandle_base::_create();
}

unsigned long Arts::CroppedDataHandle_base::_IID = Arts::MCOPUtils::makeIID("Arts::CroppedDataHandle");

Arts::CutDataHandle_base *Arts::CutDataHandle_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::CutDataHandle_base *castedObject = (Arts::CutDataHandle_base *)skel->_cast(Arts::CutDataHandle_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::CutDataHandle_base *Arts::CutDataHandle_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::CutDataHandle_base::_fromReference(r,true);
	return 0;
}

Arts::CutDataHandle_base *Arts::CutDataHandle_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::CutDataHandle_base *castedObject = (Arts::CutDataHandle_base *)object._base()->_cast(Arts::CutDataHandle_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::CutDataHandle_base *Arts::CutDataHandle_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::CutDataHandle_base *result;
	result = (Arts::CutDataHandle_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::CutDataHandle");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::CutDataHandle_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::CutDataHandle")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::CutDataHandle_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::CutDataHandle_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::CutDataHandle_base::_cast(unsigned long iid)
{
	if(iid == Arts::CutDataHandle_base::_IID) return (Arts::CutDataHandle_base *)this;
	if(iid == Arts::DataHandle_base::_IID) return (Arts::DataHandle_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::CutDataHandle_stub::CutDataHandle_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::CutDataHandle_stub::CutDataHandle_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::CutDataHandle_stub::init(Arts::DataHandle sourceHandle, long cutOffset, long cutValueCount)
{
	long methodID = _lookupMethodFast("method:00000005696e69740000000005766f696400000000020000000300000011417274733a3a4461746148616e646c65000000000d736f7572636548616e646c650000000000000000056c6f6e67000000000a6375744f66667365740000000000000000056c6f6e67000000000e63757456616c7565436f756e74000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,sourceHandle._base());
	request->writeLong(cutOffset);
	request->writeLong(cutValueCount);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::CutDataHandle_skel::_interfaceName()
{
	return "Arts::CutDataHandle";
}

bool Arts::CutDataHandle_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::CutDataHandle") return true;
	if (interfacename == "Arts::DataHandle") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::CutDataHandle_skel::_interfaceNameSkel()
{
	return "Arts::CutDataHandle";
}

// init
static void _dispatch_Arts_CutDataHandle_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::DataHandle_base* _temp_sourceHandle;
	Arts::readObject(*request,_temp_sourceHandle);
	Arts::DataHandle sourceHandle = Arts::DataHandle::_from_base(_temp_sourceHandle);
	long cutOffset = request->readLong();
	long cutValueCount = request->readLong();
	((Arts::CutDataHandle_skel *)object)->init(sourceHandle,cutOffset,cutValueCount);
}

void Arts::CutDataHandle_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:00000005696e69740000000005766f696400000000020000000300"
        "000011417274733a3a4461746148616e646c65000000000d736f7572636548616e"
        "646c650000000000000000056c6f6e67000000000a6375744f6666736574000000"
        "0000000000056c6f6e67000000000e63757456616c7565436f756e740000000000"
        "00000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_CutDataHandle_00,this,Arts::MethodDef(m));
	Arts::DataHandle_skel::_buildMethodTable();
}

Arts::CutDataHandle_skel::CutDataHandle_skel()
{
}

Arts::Object_base* Arts::CutDataHandle::_Creator() {
	return Arts::CutDataHandle_base::_create();
}

unsigned long Arts::CutDataHandle_base::_IID = Arts::MCOPUtils::makeIID("Arts::CutDataHandle");

Arts::DataHandlePlay_base *Arts::DataHandlePlay_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::DataHandlePlay_base *castedObject = (Arts::DataHandlePlay_base *)skel->_cast(Arts::DataHandlePlay_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::DataHandlePlay_base *Arts::DataHandlePlay_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::DataHandlePlay_base::_fromReference(r,true);
	return 0;
}

Arts::DataHandlePlay_base *Arts::DataHandlePlay_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::DataHandlePlay_base *castedObject = (Arts::DataHandlePlay_base *)object._base()->_cast(Arts::DataHandlePlay_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::DataHandlePlay_base *Arts::DataHandlePlay_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::DataHandlePlay_base *result;
	result = (Arts::DataHandlePlay_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::DataHandlePlay");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::DataHandlePlay_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::DataHandlePlay")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::DataHandlePlay_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::DataHandlePlay_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outvalue");
	return ret;
}

void *Arts::DataHandlePlay_base::_cast(unsigned long iid)
{
	if(iid == Arts::DataHandlePlay_base::_IID) return (Arts::DataHandlePlay_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::DataHandlePlay_stub::DataHandlePlay_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::DataHandlePlay_stub::DataHandlePlay_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

Arts::DataHandlePlay Arts::DataHandlePlay_stub::clone()
{
	long methodID = _lookupMethodFast("method:00000006636c6f6e650000000015417274733a3a4461746148616e646c65506c617900000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if (!result) return Arts::DataHandlePlay::null();
	Arts::DataHandlePlay_base* returnCode;
	Arts::readObject(*result,returnCode);
	delete result;
	return Arts::DataHandlePlay::_from_base(returnCode);
}

Arts::DataHandle Arts::DataHandlePlay_stub::handle()
{
	long methodID = _lookupMethodFast("method:0000000c5f6765745f68616e646c650000000011417274733a3a4461746148616e646c6500000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if (!result) return Arts::DataHandle::null();
	Arts::DataHandle_base* returnCode;
	Arts::readObject(*result,returnCode);
	delete result;
	return Arts::DataHandle::_from_base(returnCode);
}

void Arts::DataHandlePlay_stub::handle(Arts::DataHandle newValue)
{
	long methodID = _lookupMethodFast("method:0000000c5f7365745f68616e646c650000000005766f696400000000020000000100000011417274733a3a4461746148616e646c6500000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,newValue._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

float Arts::DataHandlePlay_stub::mixerFrequency()
{
	long methodID = _lookupMethodFast("method:000000145f6765745f6d697865724672657175656e63790000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

void Arts::DataHandlePlay_stub::mixerFrequency(float newValue)
{
	long methodID = _lookupMethodFast("method:000000145f7365745f6d697865724672657175656e63790000000005766f696400000000020000000100000006666c6f617400000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeFloat(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::DataHandlePlay_stub::channelIndex()
{
	long methodID = _lookupMethodFast("method:000000125f6765745f6368616e6e656c496e64657800000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::DataHandlePlay_stub::channelIndex(long newValue)
{
	long methodID = _lookupMethodFast("method:000000125f7365745f6368616e6e656c496e6465780000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

float Arts::DataHandlePlay_stub::speed()
{
	long methodID = _lookupMethodFast("method:0000000b5f6765745f73706565640000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

void Arts::DataHandlePlay_stub::speed(float newValue)
{
	long methodID = _lookupMethodFast("method:0000000b5f7365745f73706565640000000005766f696400000000020000000100000006666c6f617400000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeFloat(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::DataHandlePlay_stub::pos()
{
	long methodID = _lookupMethodFast("method:000000095f6765745f706f7300000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occurred
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::DataHandlePlay_stub::pos(long newValue)
{
	long methodID = _lookupMethodFast("method:000000095f7365745f706f730000000005766f6964000000000200000001000000056c6f6e6700000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

bool Arts::DataHandlePlay_stub::finished()
{
	long methodID = _lookupMethodFast("method:0000000e5f6765745f66696e69736865640000000008626f6f6c65616e00000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occurred
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

bool Arts::DataHandlePlay_stub::paused()
{
	long methodID = _lookupMethodFast("method:0000000c5f6765745f7061757365640000000008626f6f6c65616e00000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occurred
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

void Arts::DataHandlePlay_stub::paused(bool newValue)
{
	long methodID = _lookupMethodFast("method:0000000c5f7365745f7061757365640000000005766f696400000000020000000100000008626f6f6c65616e00000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeBool(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::DataHandlePlay_skel::_interfaceName()
{
	return "Arts::DataHandlePlay";
}

bool Arts::DataHandlePlay_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::DataHandlePlay") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::DataHandlePlay_skel::_interfaceNameSkel()
{
	return "Arts::DataHandlePlay";
}

// clone
static void _dispatch_Arts_DataHandlePlay_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	Arts::DataHandlePlay returnCode = ((Arts::DataHandlePlay_skel *)object)->clone();
	Arts::writeObject(*result,returnCode._base());
}

// _get_handle
static void _dispatch_Arts_DataHandlePlay_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	Arts::DataHandle returnCode = ((Arts::DataHandlePlay_skel *)object)->handle();
	Arts::writeObject(*result,returnCode._base());
}

// _set_handle
static void _dispatch_Arts_DataHandlePlay_02(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::DataHandle_base* _temp_newValue;
	Arts::readObject(*request,_temp_newValue);
	Arts::DataHandle newValue = Arts::DataHandle::_from_base(_temp_newValue);
	((Arts::DataHandlePlay_skel *)object)->handle(newValue);
}

// _get_mixerFrequency
static void _dispatch_Arts_DataHandlePlay_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::DataHandlePlay_skel *)object)->mixerFrequency());
}

// _set_mixerFrequency
static void _dispatch_Arts_DataHandlePlay_04(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	float newValue = request->readFloat();
	((Arts::DataHandlePlay_skel *)object)->mixerFrequency(newValue);
}

// _get_channelIndex
static void _dispatch_Arts_DataHandlePlay_05(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::DataHandlePlay_skel *)object)->channelIndex());
}

// _set_channelIndex
static void _dispatch_Arts_DataHandlePlay_06(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::DataHandlePlay_skel *)object)->channelIndex(newValue);
}

// _get_speed
static void _dispatch_Arts_DataHandlePlay_07(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::DataHandlePlay_skel *)object)->speed());
}

// _set_speed
static void _dispatch_Arts_DataHandlePlay_08(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	float newValue = request->readFloat();
	((Arts::DataHandlePlay_skel *)object)->speed(newValue);
}

// _get_pos
static void _dispatch_Arts_DataHandlePlay_09(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::DataHandlePlay_skel *)object)->pos());
}

// _set_pos
static void _dispatch_Arts_DataHandlePlay_10(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long newValue = request->readLong();
	((Arts::DataHandlePlay_skel *)object)->pos(newValue);
}

// _get_finished
static void _dispatch_Arts_DataHandlePlay_11(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeBool(((Arts::DataHandlePlay_skel *)object)->finished());
}

// _get_paused
static void _dispatch_Arts_DataHandlePlay_12(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeBool(((Arts::DataHandlePlay_skel *)object)->paused());
}

// _set_paused
static void _dispatch_Arts_DataHandlePlay_13(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	bool newValue = request->readBool();
	((Arts::DataHandlePlay_skel *)object)->paused(newValue);
}

void Arts::DataHandlePlay_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:00000006636c6f6e650000000015417274733a3a4461746148616e"
        "646c65506c6179000000000200000000000000000000000c5f6765745f68616e64"
        "6c650000000011417274733a3a4461746148616e646c6500000000020000000000"
        "0000000000000c5f7365745f68616e646c650000000005766f6964000000000200"
        "00000100000011417274733a3a4461746148616e646c6500000000096e65775661"
        "6c7565000000000000000000000000145f6765745f6d697865724672657175656e"
        "63790000000006666c6f617400000000020000000000000000000000145f736574"
        "5f6d697865724672657175656e63790000000005766f6964000000000200000001"
        "00000006666c6f617400000000096e657756616c75650000000000000000000000"
        "00125f6765745f6368616e6e656c496e64657800000000056c6f6e670000000002"
        "0000000000000000000000125f7365745f6368616e6e656c496e64657800000000"
        "05766f6964000000000200000001000000056c6f6e6700000000096e657756616c"
        "75650000000000000000000000000b5f6765745f73706565640000000006666c6f"
        "6174000000000200000000000000000000000b5f7365745f737065656400000000"
        "05766f696400000000020000000100000006666c6f617400000000096e65775661"
        "6c7565000000000000000000000000095f6765745f706f7300000000056c6f6e67"
        "00000000020000000000000000000000095f7365745f706f730000000005766f69"
        "64000000000200000001000000056c6f6e6700000000096e657756616c75650000"
        "000000000000000000000e5f6765745f66696e69736865640000000008626f6f6c"
        "65616e000000000200000000000000000000000c5f6765745f7061757365640000"
        "000008626f6f6c65616e000000000200000000000000000000000c5f7365745f70"
        "61757365640000000005766f696400000000020000000100000008626f6f6c6561"
        "6e00000000096e657756616c7565000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_DataHandlePlay_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_05,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_06,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_07,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_08,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_09,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_10,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_11,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_12,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_DataHandlePlay_13,this,Arts::MethodDef(m));
	Arts::SynthModule_skel::_buildMethodTable();
}

Arts::DataHandlePlay_skel::DataHandlePlay_skel()
{
	_initStream("outvalue",&outvalue,74);
}

Arts::Object_base* Arts::DataHandlePlay::_Creator() {
	return Arts::DataHandlePlay_base::_create();
}

unsigned long Arts::DataHandlePlay_base::_IID = Arts::MCOPUtils::makeIID("Arts::DataHandlePlay");

Arts::WaveDataHandle_base *Arts::WaveDataHandle_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::WaveDataHandle_base *castedObject = (Arts::WaveDataHandle_base *)skel->_cast(Arts::WaveDataHandle_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::WaveDataHandle_base *Arts::WaveDataHandle_base::_fromString(const std::string& objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::WaveDataHandle_base::_fromReference(r,true);
	return 0;
}

Arts::WaveDataHandle_base *Arts::WaveDataHandle_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::WaveDataHandle_base *castedObject = (Arts::WaveDataHandle_base *)object._base()->_cast(Arts::WaveDataHandle_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::WaveDataHandle_base *Arts::WaveDataHandle_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::WaveDataHandle_base *result;
	result = (Arts::WaveDataHandle_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::WaveDataHandle");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::WaveDataHandle_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::WaveDataHandle")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::WaveDataHandle_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::WaveDataHandle_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::WaveDataHandle_base::_cast(unsigned long iid)
{
	if(iid == Arts::WaveDataHandle_base::_IID) return (Arts::WaveDataHandle_base *)this;
	if(iid == Arts::DataHandle_base::_IID) return (Arts::DataHandle_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::WaveDataHandle_stub::WaveDataHandle_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::WaveDataHandle_stub::WaveDataHandle_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

bool Arts::WaveDataHandle_stub::load(const std::string& filename)
{
	long methodID = _lookupMethodFast("method:000000056c6f61640000000008626f6f6c65616e00000000020000000100000007737472696e67000000000966696c656e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(filename);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occurred
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

bool Arts::WaveDataHandle_stub::load(const std::string& filename, long waveIndex, long chunkIndex)
{
	long methodID = _lookupMethodFast("method:000000056c6f61640000000008626f6f6c65616e00000000020000000300000007737472696e67000000000966696c656e616d650000000000000000056c6f6e67000000000a77617665496e6465780000000000000000056c6f6e67000000000b6368756e6b496e646578000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(filename);
	request->writeLong(waveIndex);
	request->writeLong(chunkIndex);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occurred
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

Arts::DataHandlePlay Arts::WaveDataHandle_stub::createPlayer()
{
	long methodID = _lookupMethodFast("method:0000000d637265617465506c617965720000000015417274733a3a4461746148616e646c65506c617900000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if (!result) return Arts::DataHandlePlay::null();
	Arts::DataHandlePlay_base* returnCode;
	Arts::readObject(*result,returnCode);
	delete result;
	return Arts::DataHandlePlay::_from_base(returnCode);
}

float Arts::WaveDataHandle_stub::mixerFrequency()
{
	long methodID = _lookupMethodFast("method:000000145f6765745f6d697865724672657175656e63790000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

float Arts::WaveDataHandle_stub::oscillatorFrequency()
{
	long methodID = _lookupMethodFast("method:000000195f6765745f6f7363696c6c61746f724672657175656e63790000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occurred
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

bool Arts::WaveDataHandle_stub::isLoaded()
{
	long methodID = _lookupMethodFast("method:0000000e5f6765745f69734c6f616465640000000008626f6f6c65616e00000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occurred
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

std::string Arts::WaveDataHandle_skel::_interfaceName()
{
	return "Arts::WaveDataHandle";
}

bool Arts::WaveDataHandle_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::WaveDataHandle") return true;
	if (interfacename == "Arts::DataHandle") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::WaveDataHandle_skel::_interfaceNameSkel()
{
	return "Arts::WaveDataHandle";
}

// load
static void _dispatch_Arts_WaveDataHandle_00(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string filename;
	request->readString(filename);
	result->writeBool(((Arts::WaveDataHandle_skel *)object)->load(filename));
}

// load
static void _dispatch_Arts_WaveDataHandle_01(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string filename;
	request->readString(filename);
	long waveIndex = request->readLong();
	long chunkIndex = request->readLong();
	result->writeBool(((Arts::WaveDataHandle_skel *)object)->load(filename,waveIndex,chunkIndex));
}

// createPlayer
static void _dispatch_Arts_WaveDataHandle_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	Arts::DataHandlePlay returnCode = ((Arts::WaveDataHandle_skel *)object)->createPlayer();
	Arts::writeObject(*result,returnCode._base());
}

// _get_mixerFrequency
static void _dispatch_Arts_WaveDataHandle_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::WaveDataHandle_skel *)object)->mixerFrequency());
}

// _get_oscillatorFrequency
static void _dispatch_Arts_WaveDataHandle_04(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((Arts::WaveDataHandle_skel *)object)->oscillatorFrequency());
}

// _get_isLoaded
static void _dispatch_Arts_WaveDataHandle_05(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeBool(((Arts::WaveDataHandle_skel *)object)->isLoaded());
}

void Arts::WaveDataHandle_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:000000056c6f61640000000008626f6f6c65616e00000000020000"
        "000100000007737472696e67000000000966696c656e616d650000000000000000"
        "00000000056c6f61640000000008626f6f6c65616e000000000200000003000000"
        "07737472696e67000000000966696c656e616d650000000000000000056c6f6e67"
        "000000000a77617665496e6465780000000000000000056c6f6e67000000000b63"
        "68756e6b496e6465780000000000000000000000000d637265617465506c617965"
        "720000000015417274733a3a4461746148616e646c65506c617900000000020000"
        "000000000000000000145f6765745f6d697865724672657175656e637900000000"
        "06666c6f617400000000020000000000000000000000195f6765745f6f7363696c"
        "6c61746f724672657175656e63790000000006666c6f6174000000000200000000"
        "000000000000000e5f6765745f69734c6f616465640000000008626f6f6c65616e"
        "00000000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_WaveDataHandle_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_WaveDataHandle_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_WaveDataHandle_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_WaveDataHandle_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_WaveDataHandle_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_WaveDataHandle_05,this,Arts::MethodDef(m));
	Arts::DataHandle_skel::_buildMethodTable();
}

Arts::WaveDataHandle_skel::WaveDataHandle_skel()
{
}

Arts::Object_base* Arts::WaveDataHandle::_Creator() {
	return Arts::WaveDataHandle_base::_create();
}

unsigned long Arts::WaveDataHandle_base::_IID = Arts::MCOPUtils::makeIID("Arts::WaveDataHandle");

static Arts::IDLFileReg IDLFileReg_artsflow("artsflow",
    "IDLFile:00000001000000000200000017417274733a3a4175746f53757370656e6453"
    "7461746500000000070000000c61734e6f53757370656e640000000000000000000000"
    "000a617353757370656e640000000001000000000000000e617353757370656e645374"
    "6f700000000002000000000000000e617353757370656e644d61736b00000000030000"
    "00000000000b617350726f64756365720000000010000000000000000b6173436f6e73"
    "756d6572000000002000000000000000106173446972656374696f6e4d61736b000000"
    "003000000000000000000000001c417274733a3a417564696f4d616e61676572446972"
    "656374696f6e000000000200000007616d506c61790000000000000000000000000961"
    "6d5265636f7264000000000100000000000000000000000100000017417274733a3a41"
    "7564696f4d616e61676572496e666f0000000005000000056c6f6e6700000000034944"
    "000000000000000007737472696e67000000000c64657374696e6174696f6e00000000"
    "000000001c417274733a3a417564696f4d616e61676572446972656374696f6e000000"
    "000a646972656374696f6e000000000000000007737472696e6700000000067469746c"
    "65000000000000000007737472696e67000000000e6175746f526573746f7265494400"
    "00000000000000000000001b00000012417274733a3a53796e74684d6f64756c650000"
    "000000000000050000000673746172740000000005766f696400000000020000000000"
    "0000000000000573746f700000000005766f6964000000000200000000000000000000"
    "000b73747265616d496e69740000000005766f69640000000002000000000000000000"
    "00000c73747265616d53746172740000000005766f6964000000000200000000000000"
    "000000000a73747265616d456e640000000005766f6964000000000200000000000000"
    "00000000010000000c6175746f53757370656e640000000017417274733a3a4175746f"
    "53757370656e6453746174650000000012000000000000000000000000000000114172"
    "74733a3a53796e74685f504c4159000000000100000012417274733a3a53796e74684d"
    "6f64756c650000000000000000020000000d696e76616c75655f6c6566740000000006"
    "666c6f61740000000049000000000000000e696e76616c75655f726967687400000000"
    "06666c6f6174000000004900000000000000020000000d696e76616c75655f6c656674"
    "000000000e696e76616c75655f7269676874000000000000000013417274733a3a5379"
    "6e74685f5245434f5244000000000100000012417274733a3a53796e74684d6f64756c"
    "65000000000000000002000000056c6566740000000006666c6f6174000000004a0000"
    "00000000000672696768740000000006666c6f6174000000004a000000000000000200"
    "0000056c65667400000000067269676874000000000000000016417274733a3a53796e"
    "74685f4652455155454e4359000000000100000012417274733a3a53796e74684d6f64"
    "756c650000000000000000020000000a6672657175656e63790000000006666c6f6174"
    "00000000090000000000000004706f730000000006666c6f6174000000000a00000000"
    "000000000000000000000015417274733a3a53796e74685f574156455f53494e000000"
    "000100000012417274733a3a53796e74684d6f64756c65000000000000000002000000"
    "04706f730000000006666c6f6174000000000900000000000000096f757476616c7565"
    "0000000006666c6f6174000000000a0000000000000000000000000000001641727473"
    "3a3a53796e74685f4d554c54495f414444000000000100000012417274733a3a53796e"
    "74684d6f64756c6500000000000000000200000008696e76616c75650000000006666c"
    "6f6174000000000d00000000000000096f757476616c75650000000006666c6f617400"
    "0000000a00000000000000000000000000000010417274733a3a53796e74685f414444"
    "000000000100000012417274733a3a53796e74684d6f64756c65000000000000000003"
    "00000009696e76616c7565310000000006666c6f617400000000490000000000000009"
    "696e76616c7565320000000006666c6f6174000000004900000000000000096f757476"
    "616c75650000000006666c6f6174000000000a000000000000000200000009696e7661"
    "6c7565310000000009696e76616c756532000000000000000010417274733a3a53796e"
    "74685f4d554c000000000100000012417274733a3a53796e74684d6f64756c65000000"
    "00000000000300000009696e76616c7565310000000006666c6f617400000000090000"
    "000000000009696e76616c7565320000000006666c6f61740000000009000000000000"
    "00096f757476616c75650000000006666c6f6174000000000a00000000000000020000"
    "0009696e76616c7565320000000009696e76616c756531000000000000000015417274"
    "733a3a53796e74685f504c41595f574156000000000100000012417274733a3a53796e"
    "74684d6f64756c650000000000000000050000000673706565640000000006666c6f61"
    "740000000013000000000000000966696c656e616d650000000007737472696e670000"
    "000013000000000000000966696e69736865640000000008626f6f6c65616e00000000"
    "1200000000000000056c6566740000000006666c6f6174000000000a00000000000000"
    "0672696768740000000006666c6f6174000000000a0000000000000002000000067269"
    "67687400000000056c656674000000000000000017417274733a3a53796e74685f4255"
    "535f55504c494e4b000000000100000012417274733a3a53796e74684d6f64756c6500"
    "0000000000000003000000086275736e616d650000000007737472696e670000000013"
    "00000000000000056c6566740000000006666c6f617400000000490000000000000006"
    "72696768740000000006666c6f617400000000490000000000000002000000056c6566"
    "7400000000067269676874000000000000000019417274733a3a53796e74685f425553"
    "5f444f574e4c494e4b000000000100000012417274733a3a53796e74684d6f64756c65"
    "000000000000000003000000086275736e616d650000000007737472696e6700000000"
    "1300000000000000056c6566740000000006666c6f6174000000004a00000000000000"
    "0672696768740000000006666c6f6174000000004a0000000000000002000000056c65"
    "667400000000067269676874000000000000000018417274733a3a4279746553747265"
    "616d546f417564696f000000000100000012417274733a3a53796e74684d6f64756c65"
    "0000000000000000070000000d73616d706c696e675261746500000000056c6f6e6700"
    "0000001300000000000000096368616e6e656c7300000000056c6f6e67000000001300"
    "000000000000056269747300000000056c6f6e67000000001300000000000000087275"
    "6e6e696e670000000008626f6f6c65616e00000000120000000000000007696e646174"
    "61000000000562797465000000002900000000000000056c6566740000000006666c6f"
    "6174000000000a000000000000000672696768740000000006666c6f6174000000000a"
    "0000000000000002000000056c65667400000000067269676874000000000000000018"
    "417274733a3a417564696f546f4279746553747265616d000000000100000012417274"
    "733a3a53796e74684d6f64756c650000000000000000060000000d73616d706c696e67"
    "5261746500000000056c6f6e67000000001300000000000000096368616e6e656c7300"
    "000000056c6f6e67000000001300000000000000056269747300000000056c6f6e6700"
    "0000001300000000000000086f757464617461000000000562797465000000002a0000"
    "0000000000056c6566740000000006666c6f6174000000000900000000000000067269"
    "6768740000000006666c6f617400000000090000000000000002000000056c65667400"
    "000000067269676874000000000000000013417274733a3a53746572656f4566666563"
    "74000000000100000012417274733a3a53796e74684d6f64756c650000000000000000"
    "0400000007696e6c6566740000000006666c6f61740000000049000000000000000869"
    "6e72696768740000000006666c6f6174000000004900000000000000086f75746c6566"
    "740000000006666c6f6174000000004a00000000000000096f75747269676874000000"
    "0006666c6f6174000000004a000000000000000400000007696e6c6566740000000008"
    "696e726967687400000000086f75746c65667400000000096f75747269676874000000"
    "00000000001a417274733a3a53746572656f566f6c756d65436f6e74726f6c00000000"
    "0100000013417274733a3a53746572656f456666656374000000000000000003000000"
    "0c7363616c65466163746f720000000006666c6f617400000000130000000000000012"
    "63757272656e74566f6c756d654c6566740000000006666c6f61740000000012000000"
    "000000001363757272656e74566f6c756d6552696768740000000006666c6f61740000"
    "00001200000000000000000000000000000015417274733a3a53746572656f46465453"
    "636f7065000000000100000013417274733a3a53746572656f45666665637400000000"
    "00000000010000000673636f706500000000072a666c6f617400000000120000000000"
    "0000000000000000000018417274733a3a53746572656f456666656374537461636b00"
    "0000000100000013417274733a3a53746572656f45666665637400000000030000000a"
    "696e73657274546f7000000000056c6f6e670000000002000000020000001341727473"
    "3a3a53746572656f456666656374000000000765666665637400000000000000000773"
    "7472696e6700000000056e616d650000000000000000000000000d696e73657274426f"
    "74746f6d00000000056c6f6e6700000000020000000200000013417274733a3a537465"
    "72656f4566666563740000000007656666656374000000000000000007737472696e67"
    "00000000056e616d650000000000000000000000000772656d6f76650000000005766f"
    "6964000000000200000001000000056c6f6e6700000000034944000000000000000000"
    "00000000000000000000000000000019417274733a3a417564696f4d616e6167657243"
    "6c69656e740000000000000000010000000c636f6e7374727563746f72000000000576"
    "6f69640000000002000000030000001c417274733a3a417564696f4d616e6167657244"
    "6972656374696f6e000000000a646972656374696f6e00000000000000000773747269"
    "6e6700000000067469746c65000000000000000007737472696e67000000000e617574"
    "6f526573746f726549440000000000000000000000000400000003494400000000056c"
    "6f6e670000000012000000000000000a646972656374696f6e000000001c417274733a"
    "3a417564696f4d616e61676572446972656374696f6e00000000130000000000000006"
    "7469746c650000000007737472696e670000000013000000000000000e6175746f5265"
    "73746f726549440000000007737472696e670000000013000000000000000000000000"
    "00000013417274733a3a417564696f4d616e616765720000000000000000010000000f"
    "73657444657374696e6174696f6e0000000005766f6964000000000200000002000000"
    "056c6f6e6700000000034944000000000000000007737472696e67000000000c646573"
    "74696e6174696f6e000000000000000000000000030000000d64657374696e6174696f"
    "6e7300000000082a737472696e6700000000120000000000000008636c69656e747300"
    "000000182a417274733a3a417564696f4d616e61676572496e666f0000000012000000"
    "00000000086368616e67657300000000056c6f6e670000000012000000000000000000"
    "00000000000016417274733a3a53796e74685f414d414e5f504c415900000000010000"
    "0012417274733a3a53796e74684d6f64756c6500000000010000000c636f6e73747275"
    "63746f720000000005766f696400000000020000000100000019417274733a3a417564"
    "696f4d616e61676572436c69656e740000000007636c69656e74000000000000000000"
    "00000004000000067469746c650000000007737472696e670000000013000000000000"
    "000e6175746f526573746f726549440000000007737472696e67000000001300000000"
    "000000056c6566740000000006666c6f61740000000049000000000000000672696768"
    "740000000006666c6f617400000000490000000000000002000000056c656674000000"
    "00067269676874000000000000000018417274733a3a53796e74685f414d414e5f5245"
    "434f5244000000000100000012417274733a3a53796e74684d6f64756c650000000001"
    "0000000c636f6e7374727563746f720000000005766f69640000000002000000010000"
    "0019417274733a3a417564696f4d616e61676572436c69656e740000000007636c6965"
    "6e7400000000000000000000000004000000067469746c650000000007737472696e67"
    "0000000013000000000000000e6175746f526573746f72654944000000000773747269"
    "6e67000000001300000000000000056c6566740000000006666c6f6174000000004a00"
    "0000000000000672696768740000000006666c6f6174000000004a0000000000000002"
    "000000056c65667400000000067269676874000000000000000011417274733a3a4461"
    "746148616e646c65000000000000000000000000040000000962697444657074680000"
    "0000056c6f6e670000000012000000000000000d6368616e6e656c436f756e74000000"
    "00056c6f6e670000000012000000000000000b76616c7565436f756e7400000000056c"
    "6f6e67000000001200000000000000086572726f724e6f00000000056c6f6e67000000"
    "001200000000000000000000000000000019417274733a3a5265766572736564446174"
    "6148616e646c65000000000100000011417274733a3a4461746148616e646c65000000"
    "000100000005696e69740000000005766f696400000000020000000100000011417274"
    "733a3a4461746148616e646c65000000000d736f7572636548616e646c650000000000"
    "0000000000000000000000000000000000000018417274733a3a43726f707065644461"
    "746148616e646c65000000000100000011417274733a3a4461746148616e646c650000"
    "00000100000005696e69740000000005766f6964000000000200000003000000114172"
    "74733a3a4461746148616e646c65000000000d736f7572636548616e646c6500000000"
    "00000000056c6f6e6700000000126865616443757456616c7565436f756e7400000000"
    "00000000056c6f6e6700000000127461696c43757456616c7565436f756e7400000000"
    "000000000000000000000000000000000000000014417274733a3a4375744461746148"
    "616e646c65000000000100000011417274733a3a4461746148616e646c650000000001"
    "00000005696e69740000000005766f696400000000020000000300000011417274733a"
    "3a4461746148616e646c65000000000d736f7572636548616e646c6500000000000000"
    "00056c6f6e67000000000a6375744f66667365740000000000000000056c6f6e670000"
    "00000e63757456616c7565436f756e7400000000000000000000000000000000000000"
    "000000000015417274733a3a4461746148616e646c65506c6179000000000100000012"
    "417274733a3a53796e74684d6f64756c65000000000100000006636c6f6e6500000000"
    "15417274733a3a4461746148616e646c65506c61790000000002000000000000000000"
    "0000080000000768616e646c650000000011417274733a3a4461746148616e646c6500"
    "00000013000000000000000f6d697865724672657175656e63790000000006666c6f61"
    "740000000013000000000000000d6368616e6e656c496e64657800000000056c6f6e67"
    "0000000013000000000000000673706565640000000006666c6f617400000000130000"
    "000000000004706f7300000000056c6f6e670000000013000000000000000966696e69"
    "736865640000000008626f6f6c65616e00000000120000000000000007706175736564"
    "0000000008626f6f6c65616e000000001300000000000000096f757476616c75650000"
    "000006666c6f6174000000004a0000000000000001000000096f757476616c75650000"
    "00000000000015417274733a3a576176654461746148616e646c650000000001000000"
    "11417274733a3a4461746148616e646c650000000003000000056c6f61640000000008"
    "626f6f6c65616e00000000020000000100000007737472696e67000000000966696c65"
    "6e616d65000000000000000000000000056c6f61640000000008626f6f6c65616e0000"
    "0000020000000300000007737472696e67000000000966696c656e616d650000000000"
    "000000056c6f6e67000000000a77617665496e6465780000000000000000056c6f6e67"
    "000000000b6368756e6b496e6465780000000000000000000000000d63726561746550"
    "6c617965720000000015417274733a3a4461746148616e646c65506c61790000000002"
    "0000000000000000000000030000000f6d697865724672657175656e63790000000006"
    "666c6f6174000000001200000000000000146f7363696c6c61746f724672657175656e"
    "63790000000006666c6f61740000000012000000000000000969734c6f616465640000"
    "000008626f6f6c65616e000000001200000000000000000000000000000000"
);
